
// MIT License

// Copyright (c) 2020 Tsukanov Alexander

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#Область Константы

Перем КлючевыеСлова;             // перечисление
Перем Токены;                    // перечисление
Перем Узлы;                      // перечисление
Перем Директивы;                 // перечисление
Перем ИнструкцииПрепроцессора;   // перечисление
Перем СимволыПрепроцессора;      // перечисление
Перем ЛитералКромеСтроки;        // массив (один из Токены)
Перем ОперацииСравнения;         // массив (один из Токены)
Перем ОперацииАддитивные;        // массив (один из Токены)
Перем ОперацииМультипликативные; // массив (один из Токены)
Перем ТокеныНачалаВыражения;     // массив (один из Токены)
Перем ПустойМассив;              // массив
Перем КартаТокенов;              // соответствие[строка] (строка)
Перем КартаБуквЦифр;             // соответствие[строка] (строка)
Перем Буква, Цифра;              // строка
Перем Символы_ПС;                // строка
Перем Канон;                     // соответствие[строка] (булево)

#КонецОбласти // Константы

#Область СостояниеПарсера

Перем Парсер_Исходник;             // строка
Перем Парсер_ДлинаИсходника;       // число
Перем Парсер_НомерТекущейСтроки;   // число
Перем Парсер_НомерПоследнейСтроки; // число
Перем Парсер_ТекущаяПозиция;       // число
Перем Парсер_ПозицияНачала;        // число
Перем Парсер_ПозицияКонца;         // число
Перем Парсер_Символ;               // строка
Перем Парсер_Токен;                // строка (один из Токены)
Перем Парсер_Литерал;              // строка
Перем Парсер_Значение;             // число, строка, дата, булево, неопределено, null
Перем Парсер_Окружение;            // структура (Окружение)
Перем Парсер_Переменные;           // структура как соответствие[строка] (ЭлементОкружения)
Перем Парсер_Методы;               // структура как соответствие[строка] (ЭлементОкружения)
Перем Парсер_Неизвестные;          // структура как соответствие[строка] (ЭлементОкружения)
Перем Парсер_ТочкиВызова;          // соответствие[ЭлементОкружения] (Место)
Перем Парсер_ЭтоФункция;           // булево
Перем Парсер_ПеременныеРазрешены;  // булево
Перем Парсер_СписокДиректив;       // массив (один из Директивы)
Перем Парсер_Интерфейс;            // массив (ЭлементОкружения)
Перем Парсер_Комментарии;          // соответствие[число] (строка)
Перем Парсер_Ошибки;               // таблица

#КонецОбласти // СостояниеПарсера

#Область СостояниеПосетителя

Перем Посетитель_Плагины;  // массив (Обработка)
Перем Посетитель_Подписки; // структура как соответствие[строка] (массив)
Перем Посетитель_Стек;     // структура
Перем Посетитель_Счетчики; // структура как соответствие[строка] (число)

#КонецОбласти // СостояниеПосетителя

#Область Инициализация

Процедура Инициализировать()
	Перем Буквы, Элемент, Индекс, Символ;

	ИнициализироватьПеречисления();

	Канон = Новый Соответствие;
	Для Каждого Элемент Из КлючевыеСлова Цикл
		Канон[Элемент.Ключ] = Истина;
	КонецЦикла;

	ЛитералКромеСтроки = Новый Массив;
	ЛитералКромеСтроки.Добавить(Токены.Число);
	ЛитералКромеСтроки.Добавить(Токены.ДатаВремя);
	ЛитералКромеСтроки.Добавить(Токены.Истина);
	ЛитералКромеСтроки.Добавить(Токены.Ложь);
	ЛитералКромеСтроки.Добавить(Токены.Неопределено);
	ЛитералКромеСтроки.Добавить(Токены.Null);

	ОперацииСравнения = Новый Массив;
	ОперацииСравнения.Добавить(Токены.ЗнакРавно);
	ОперацииСравнения.Добавить(Токены.ЗнакНеРавно);
	ОперацииСравнения.Добавить(Токены.ЗнакМеньше);
	ОперацииСравнения.Добавить(Токены.ЗнакБольше);
	ОперацииСравнения.Добавить(Токены.ЗнакМеньшеИлиРавно);
	ОперацииСравнения.Добавить(Токены.ЗнакБольшеИлиРавно);

	ОперацииАддитивные = Новый Массив;
	ОперацииАддитивные.Добавить(Токены.ЗнакСложения);
	ОперацииАддитивные.Добавить(Токены.ЗнакВычитания);

	ОперацииМультипликативные = Новый Массив;
	ОперацииМультипликативные.Добавить(Токены.ЗнакУмножения);
	ОперацииМультипликативные.Добавить(Токены.ЗнакДеления);
	ОперацииМультипликативные.Добавить(Токены.ЗнакОстатка);

	ТокеныНачалаВыражения = Новый Массив;
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакСложения);
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакВычитания);
	ТокеныНачалаВыражения.Добавить(Токены.Не);
	ТокеныНачалаВыражения.Добавить(Токены.Идентификатор);
	ТокеныНачалаВыражения.Добавить(Токены.ЛеваяКруглаяСкобка);
	ТокеныНачалаВыражения.Добавить(Токены.Число);
	ТокеныНачалаВыражения.Добавить(Токены.Строка);
	ТокеныНачалаВыражения.Добавить(Токены.НачалоСтроки);
	ТокеныНачалаВыражения.Добавить(Токены.ДатаВремя);
	ТокеныНачалаВыражения.Добавить(Токены.ЗнакВопроса);
	ТокеныНачалаВыражения.Добавить(Токены.Новый);
	ТокеныНачалаВыражения.Добавить(Токены.Истина);
	ТокеныНачалаВыражения.Добавить(Токены.Ложь);
	ТокеныНачалаВыражения.Добавить(Токены.Неопределено);
	ТокеныНачалаВыражения.Добавить(Токены.Null);

	ПустойМассив = Новый Массив;

	Символы_ПС = Символы.ПС;

	Буква = "Буква";
	Цифра = "Цифра";

	КартаТокенов = Новый Соответствие;
	КартаБуквЦифр = Новый Соответствие;

	Буквы = (
		"abcdefghijklmnopqrstuvwxyz"
		+ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		+ "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
		+ "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"
	);
	Индекс = 1;
	Символ = "_";
	Пока Символ <> "" Цикл
		КартаТокенов[Символ] = Буква;
		КартаБуквЦифр[Символ] = Буква;
		Символ = Сред(Буквы, Индекс, 1);
		Индекс = Индекс + 1;
	КонецЦикла;

	Для Индекс = 0 По 9 Цикл
		КартаТокенов[Строка(Индекс)] = Цифра;
		КартаБуквЦифр[Строка(Индекс)] = Цифра;
	КонецЦикла;

	КартаТокенов[""""] = Токены.НачалоСтроки;
	КартаТокенов["|"] = Токены.ПродолжениеСтроки;
	КартаТокенов["'"] = Токены.ДатаВремя;
	КартаТокенов["="] = Токены.ЗнакРавно;
	КартаТокенов["+"] = Токены.ЗнакСложения;
	КартаТокенов["-"] = Токены.ЗнакВычитания;
	КартаТокенов["*"] = Токены.ЗнакУмножения;
	КартаТокенов["%"] = Токены.ЗнакОстатка;
	КартаТокенов["("] = Токены.ЛеваяКруглаяСкобка;
	КартаТокенов[")"] = Токены.ПраваяКруглаяСкобка;
	КартаТокенов["["] = Токены.ЛеваяКвадратнаяСкобка;
	КартаТокенов["]"] = Токены.ПраваяКвадратнаяСкобка;
	КартаТокенов["?"] = Токены.ЗнакВопроса;
	КартаТокенов[","] = Токены.Запятая;
	КартаТокенов["."] = Токены.Точка;
	КартаТокенов[":"] = Токены.Двоеточие;
	КартаТокенов[";"] = Токены.ТочкаСЗапятой;
	КартаТокенов[""] = Токены.КонецТекста;

КонецПроцедуры // Инициализировать()

Процедура ИнициализироватьПеречисления()
	КлючевыеСлова = КлючевыеСлова();
	Токены = Токены(КлючевыеСлова);
	Узлы = Узлы();
	Директивы = Директивы();
	ИнструкцииПрепроцессора = ИнструкцииПрепроцессора();
	СимволыПрепроцессора = СимволыПрепроцессора();
КонецПроцедуры // ИнициализироватьПеречисления()

#КонецОбласти // Инициализация

#Область Перечисления

Функция КлючевыеСлова() Экспорт
	Возврат Перечисление(Новый Структура,
		"Если.If, Тогда.Then, ИначеЕсли.ElsIf, Иначе.Else, КонецЕсли.EndIf,
		|Для.For, Каждого.Each, Из.In, По.To, Пока.While, Цикл.Do, КонецЦикла.EndDo,
		|Процедура.Procedure, КонецПроцедуры.EndProcedure, Функция.Function, КонецФункции.EndFunction,
		|Перем.Var, Знач.Val, Возврат.Return, Продолжить.Continue, Прервать.Break,
		|И.And, Или.Or, Не.Not, ДобавитьОбработчик.AddHandler, УдалитьОбработчик.RemoveHandler,
		|Попытка.Try, Исключение.Except, ВызватьИсключение.Raise, КонецПопытки.EndTry,
		|Новый.New, Выполнить.Execute, Экспорт.Export, Перейти.Goto,
		|Истина.True, Ложь.False, Неопределено.Undefined, Null"
	);
КонецФункции // КлючевыеСлова()

Функция Токены(КлючевыеСлова = Неопределено) Экспорт
	Перем Токены;

	Если КлючевыеСлова = Неопределено Тогда
		КлючевыеСлова = КлючевыеСлова();
	КонецЕсли;

	Токены = Перечисление(Новый Структура(КлючевыеСлова),

		// Литералы

		"Идентификатор, Число, Строка, ДатаВремя,
		// Элементы строк
		|НачалоСтроки, ПродолжениеСтроки, ОкончаниеСтроки,

		// Операции

		//       =           <>           <           >
		|ЗнакРавно, ЗнакНеРавно, ЗнакМеньше, ЗнакБольше,
		//               <=                  >=
		|ЗнакМеньшеИлиРавно, ЗнакБольшеИлиРавно,
		//          +              -              *            /            %
		|ЗнакСложения, ЗнакВычитания, ЗнакУмножения, ЗнакДеления, ЗнакОстатка,
		//                (                    )                      [                       ]
		|ЛеваяКруглаяСкобка, ПраваяКруглаяСкобка, ЛеваяКвадратнаяСкобка, ПраваяКвадратнаяСкобка,
		//         ?        ,      .          :              ;
		|ЗнакВопроса, Запятая, Точка, Двоеточие, ТочкаСЗапятой,

		// ИнструкцииПрепроцессора
		|_Если, _ИначеЕсли, _Иначе, _КонецЕсли, _Область, _КонецОбласти,

		// Другие

		//                 //          &      ~
		|КонецТекста, Comment, Директива, Метка"

	);

	Возврат Токены;
КонецФункции // Токены()

Функция Узлы() Экспорт
	Возврат Перечисление(Новый Структура,
		"Модуль, ЭлементОкружения,
		|ОбъявлениеДирективы, ОбъявлениеПеременнойМодуля, ОбъявлениеСпискаПеременныхМодуля,
		|ОбъявлениеЛокальнойПеременной, ОбъявлениеАвтоПеременной,
		|ОбъявлениеПараметра, ОбъявлениеМетода, СигнатураПроцедуры, СигнатураФункции,
		|ВыражениеЛитерал, ВыражениеПоле, ВыражениеИндекс, ВыражениеИдентификатор,
		|ВыражениеУнарное, ВыражениеБинарное, ВыражениеНовый, ВыражениеТернарное,
		|ВыражениеСкобочное, ВыражениеНе, ВыражениеСтроковое,
		|ОператорПрисваивания, ОператорВозврат, ОператорПрервать, ОператорПродолжить,
		|ОператорВызватьИсключение, ОператорВыполнить, ОператорПока, ОператорДля, ОператорДляКаждого,
		|ОператорПопытка, ОператорИсключение, ОператорПерейти, ОператорМетка,
		|ОператорВызоваПроцедуры, ОператорЕсли, ОператорИначеЕсли, ОператорИначе,
		|ОператорДобавитьОбработчик, ОператорУдалитьОбработчик,
		|ИнструкцияПрепроцессораЕсли, ИнструкцияПрепроцессораИначеЕсли, ИнструкцияПрепроцессораИначе,
		|ИнструкцияПрепроцессораКонецЕсли, ИнструкцияПрепроцессораОбласть, ИнструкцияПрепроцессораКонецОбласти,
		|ВыражениеПрепроцессораБинарное, ВыражениеПрепроцессораНе,
		|ВыражениеПрепроцессораСимвол, ВыражениеПрепроцессораСкобочное"
	);
КонецФункции // Узлы()

Функция Директивы() Экспорт
	Возврат Перечисление(Новый Структура,
		"НаКлиенте.AtClient,"
		"НаСервере.AtServer,"
		"НаСервереБезКонтекста.AtServerNoContext,"
		"НаКлиентеНаСервереБезКонтекста.AtClientAtServerNoContext,"
		"НаКлиентеНаСервере.AtClientAtServer"
	);
КонецФункции // Директивы()

Функция ИнструкцииПрепроцессора() Экспорт
	Возврат Перечисление(Новый Структура,
		"Если.If,"
		"ИначеЕсли.ElsIf,"
		"Иначе.Else,"
		"КонецЕсли.EndIf,"
		"Область.Region,"
		"КонецОбласти.EndRegion"
	);
КонецФункции // ИнструкцииПрепроцессора()

Функция СимволыПрепроцессора() Экспорт
	Возврат Перечисление(Новый Структура,
		"Клиент.Client,"
		"НаКлиенте.AtClient,"
		"НаСервере.AtServer,"
		"МобильноеПриложениеКлиент.MobileAppClient,"
		"МобильноеПриложениеСервер.MobileAppServer,"
		"ТолстыйКлиентОбычноеПриложение.ThickClientOrdinaryApplication,"
		"ТолстыйКлиентУправляемоеПриложение.ThickClientManagedApplication,"
		"Сервер.Server,"
		"ВнешнееСоединение.ExternalConnection,"
		"ТонкийКлиент.ThinClient,"
		"ВебКлиент.WebClient"
	);
КонецФункции // СимволыПрепроцессора()

Функция Перечисление(Структура, Ключи)
	Перем Элементы, Имя, Имена, Значение;

	Для Каждого Элементы Из СтрРазделить(Ключи, ",", Ложь) Цикл
		Имена = СтрРазделить(Элементы, ".", Ложь);
		Значение = СокрЛП(Имена[0]);
		Для Каждого Имя Из Имена Цикл
			Структура.Вставить(СокрЛП(Имя), Значение);
		КонецЦикла;
	КонецЦикла;

	Возврат Новый ФиксированнаяСтруктура(Структура);
КонецФункции // Перечисление()

#КонецОбласти // Перечисления

#Область АбстрактноеСинтаксическоеДерево

Функция Модуль(Объявления, АвтоПеременные, Операторы, Интерфейс, Комментарии)
	// Корень AST. Узел хранит информацию о модуле в целом.
	Возврат Новый Структура( // @Узел
		"Тип,"            // строка (один из Узлы)
		"Объявления,"     // массив (один из #Объявления)
		"АвтоПеременные," // массив (ОбъявлениеАвтоПеременной)
		"Операторы,"      // массив (один из #Операторы)
		"Интерфейс,"      // массив (ЭлементОкружения)
		"Комментарии",    // соответствие[число] (строка)
		Узлы.Модуль, Объявления, АвтоПеременные, Операторы, Интерфейс, Комментарии);
КонецФункции // Модуль()

#Область Окружение

Функция Окружение(ВнешнееОкружение)
	Возврат Новый Структура(
		"ВнешнееОкружение," // неопределено, структура (Окружение)
		"Элементы,"         // структура как соответствие[строка] (ЭлементОкружения)
		"АвтоПеременные",   // массив (ОбъявлениеАвтоПеременной)
		ВнешнееОкружение, Новый Структура, Новый Массив);
КонецФункции // Окружение()

Функция ЭлементОкружения(Имя, Объявление = Неопределено) Экспорт
	// Узел хранит информацию об объекте области видимости.
	// Поле Объявление хранит объявление данного объекта (неопределено = объявление не обнаружено).
	Возврат Новый Структура( // @Узел
		"Тип,"        // строка (один из Узлы)
		"Имя,"        // строка
		"Объявление", // неопределено, структура (один из #Объявления)
		Узлы.ЭлементОкружения, Имя, Объявление);
КонецФункции // ЭлементОкружения()

#КонецОбласти // Окружение

#Область Объявления

Функция ОбъявлениеДирективы(Директива, Место)
	// Хранит информацию об объявлении директивы.
	// Пример:
	// <pre>
	// &НаКлиенте
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Директива," // строка (один из Директивы)
		"Место",     // структура (Место)
		Узлы.ОбъявлениеДирективы, Директива, Место);
КонецФункции // ОбъявлениеДирективы()

Функция ОбъявлениеСпискаПеременныхМодуля(СписокДиректив, ОбъявленияПеременных, Место)
	// Хранит информацию об инструкции объявления переменных уровня модуля.
	// Пример:
	// <pre>
	// &НаКлиенте            // поле "Директивы"
	// Перем П1 Экспорт, П2; // поле "ОбъявленияПеременных"
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"                  // строка (один из Узлы)
		"Директивы,"            // массив (один из Директивы)
		"ОбъявленияПеременных," // массив (ОбъявлениеПеременнойМодуля)
		"Место",                // структура (Место)
		Узлы.ОбъявлениеСпискаПеременныхМодуля, СписокДиректив, ОбъявленияПеременных, Место);
КонецФункции // ОбъявлениеСпискаПеременныхМодуля()

Функция ОбъявлениеПеременнойМодуля(Имя, СписокДиректив, ЕстьЭкспорт, Место)
	// Хранит информацию об объявлении переменной уровня модуля.
	// Пример:
	// Объявления переменных заключены в скобки {...}
	// <pre>
	// &НаКлиенте
	// Перем {П1 Экспорт}, {П2};
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Директивы," // массив (один из Директивы)
		"Экспорт,"   // булево
		"Место",     // структура (Место)
		Узлы.ОбъявлениеПеременнойМодуля, Имя, СписокДиректив, ЕстьЭкспорт, Место);
КонецФункции // ОбъявлениеПеременнойМодуля()

Функция ОбъявлениеЛокальнойПеременной(Имя, Место)
	// Хранит информацию об объявлении локальной переменной.
	// Пример:
	// Объявления переменных заключены в скобки {...}
	// <pre>
	// Перем <П1>, <П2>;
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Имя,"   // строка
		"Место", // структура (Место)
		Узлы.ОбъявлениеЛокальнойПеременной, Имя, Место);
КонецФункции // ОбъявлениеЛокальнойПеременной()

Функция ОбъявлениеАвтоПеременной(Имя, Место)
	// Хранит информацию об объявлении авто-переменной.
	// Пример:
	// Объявления переменных заключены в скобки {...}
	// <pre>
	// {Макс} = 0;
	// Для {Индекс} = 0 По Массив.ВГраница() Цикл
	//	{Структура} = Массив[Индекс];
	// 	Для Каждого {Элемент} Из Структура Цикл
	//		Если Макс < Элемент.Значение Тогда
	// 			Макс = Элемент.Значение;
	// 		КонецЕсли;
	// 	КонецЦикла;
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Имя,"   // строка
		"Место", // структура (Место)
		Узлы.ОбъявлениеАвтоПеременной, Имя, Место);
КонецФункции // ОбъявлениеАвтоПеременной()

Функция ОбъявлениеПараметра(Имя, ПоЗначению, Значение, Место)
	// Хранит информацию об объявлении параметра.
	// Пример:
	// Объявления параметров заключены в скобки {...}
	// <pre>
	// Процедура({П1}, {Знач П2 = Неопределено})
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"        // строка (один из Узлы)
		"Имя,"        // строка
		"ПоЗначению," // булево
		"Значение,"   // неопределено, структура (ВыражениеУнарное, ВыражениеЛитерал)
		"Место",      // структура (Место)
		Узлы.ОбъявлениеПараметра, Имя, ПоЗначению, Значение, Место);
КонецФункции // ОбъявлениеПараметра()

Функция ОбъявлениеМетода(Сигнатура, Объявления, АвтоПеременные, Операторы, Место)
	// Хранит информацию об объявлении метода.
	// Сигнатура метода хранится в поле Сигнатура.
	// Пример:
	// <pre>
	// &НаКлиенте
	// Функция Тест() Экспорт
	//     Перем П1;    // поле "Переменные" хранит объявления переменных.
	//     П1 = 2;      // операторы собираются в поле Операторы
	//     П2 = П1 + 2; // Авто-переменные (П2) собираются в поле "АвтоПеременные".
	// КонецФункции
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"            // строка (один из Узлы)
		"Сигнатура,"      // структура (СигнатураПроцедуры, СигнатураФункции)
		"Переменные,"     // массив (ОбъявлениеЛокальнойПеременной)
		"АвтоПеременные," // массив (ОбъявлениеАвтоПеременной)
		"Операторы,"      // массив (один из #Операторы)
		"Место",          // структура (Место)
		Узлы.ОбъявлениеМетода, Сигнатура, Объявления, АвтоПеременные, Операторы, Место);
КонецФункции // ОбъявлениеМетода()

Функция СигнатураПроцедуры(Имя, СписокДиректив, Параметры, ЕстьЭкспорт, Место)
	// Хранит информацию о сигнатуре объявления процедуры.
	// Пример:
	// <pre>
	// &НаКлиенте
	// Процедура Тест(П1, П2) Экспорт
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Директивы," // массив (один из Директивы)
		"Параметры," // массив (ОбъявлениеПараметра)
		"Экспорт,"   // булево
		"Место",     // структура (Место)
		Узлы.СигнатураПроцедуры, Имя, СписокДиректив, Параметры, ЕстьЭкспорт, Место);
КонецФункции // СигнатураПроцедуры()

Функция СигнатураФункции(Имя, СписокДиректив, Параметры, ЕстьЭкспорт, Место)
	// Хранит информацию о сигнатуре объявления функции.
	// Пример:
	// <pre>
	// &НаКлиенте
	// Функция Тест(П1, П2) Экспорт
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Директивы," // массив (один из Директивы)
		"Параметры," // массив (ОбъявлениеПараметра)
		"Экспорт,"   // булево
		"Место",     // структура (Место)
		Узлы.СигнатураФункции, Имя, СписокДиректив, Параметры, ЕстьЭкспорт, Место);
КонецФункции // СигнатураФункции()

#КонецОбласти // Объявления

#Область Выражения

Функция ВыражениеЛитерал(Вид, Значение, Место)
	// Хранит информацию о литерале примитивного типа.
	Возврат Новый Структура( // @Узел
		"Тип,"      // строка (один из Узлы)
		"Вид,"      // строка (один из Токены)
		"Значение," // неопределено, строка, число, булево, дата, null
		"Место",    // структура (Место)
		Узлы.ВыражениеЛитерал, Вид, Значение, Место);
КонецФункции // ВыражениеЛитерал()

Функция ВыражениеПоле(Имя, Аргументы, Место)
	// Хранит информацию об обращении к полю объекта через точку.
	// В поле Имя содержится имя поля.
	// В поле Аргументы содержатся аргументы вызова (если это вызов).
	// Пример:
	// <pre>
	// // обращения через точку заключены в скобки {...}
	// Значение = Объект{.Поле}
	// Значение = Объект{.Добавить(П1, П2)}
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // строка
		"Аргументы," // неопределено, массив (неопределено, один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ВыражениеПоле, Имя, Аргументы, Место);
КонецФункции // ВыражениеПоле()

Функция ВыражениеИндекс(Выражение, Место)
	// Хранит информацию об обращении к элементу объекта по индексу.
	// Пример:
	// <pre>
	// // обращение по индексу заключено в скобки {...}
	// Значение = Объект<[Ключ]>
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ВыражениеИндекс, Выражение, Место);
КонецФункции // ВыражениеИндекс()

Функция ВыражениеИдентификатор(ЭлементОкружения, Хвост, Аргументы, Место)
	// Хранит информацию об обращении к идентификатору.
	// В поле Head содержится объект области видимости соответствующий идентификатору.
	// В поле Хвост содержится последовательность обращений через точку и по индексу.
	// В поле Аргументы содержатся аргументы вызова (если это вызов).
	// Пример:
	// <pre>
	// // идентификатор заключен в скобки {...}
	// // поле "Голова" будет содержать объект переменной "Запрос";
	// // поле "Хвост" будет содержать три обращения;
	// // поле "Аргументы" будет равно Неопределено, т.к. обращение к "Запрос" не является вызовом.
	// Возврат {Запрос.Выполнить().Выгрузить()[0]};
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Голова,"    // структура (ЭлементОкружения)
		"Хвост,"     // массив (ВыражениеПоле, ВыражениеИндекс)
		"Аргументы," // неопределено, массив (неопределено, один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ВыражениеИдентификатор, ЭлементОкружения, Хвост, Аргументы, Место);
КонецФункции // ВыражениеИдентификатор()

Функция ВыражениеУнарное(Операция, Операнд, Место)
	// Хранит унарное выражение.
	// Пример:
	// <pre>
	// // унарные выражения заключены в скобки {...}
	// // поле "Операция" равно либо Токены.ЗнакСложения, либо Токены.ЗнакВычитания
	// // поле "Операнд" хранит операнд-выражение
	// Значение = {-Сумма} * 2;
	// Значение = {+Сумма};
	// Значение = {-(Сумма1 + Сумма2)} / 2;
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип," // строка (один из Узлы)
		"Операция," // строка (один из Токены)
		"Операнд,"  // структура (один из #Выражения)
		"Место",    // структура (Место)
		Узлы.ВыражениеУнарное, Операция, Операнд, Место);
КонецФункции // ВыражениеУнарное()

Функция ВыражениеБинарное(ЛевыйОперанд, Операция, ПравыйОперанд, Место)
	// Хранит бинарное выражение.
	// Пример:
	// <pre>
	// // бинарные выражения заключены в скобки {...}
	// // поле "Операция" равно одному из допустимых операторов:
	// // - логических (кроме "Не")
	// // - реляционных
	// // - арифметических
	// // поля "ЛевыйОперанд" и "ПравыйОперанд" содержат операнды-выражения
	// Если {Не Отмена И Продолжить} Тогда
	//     Значение = {Сумма1 + {Сумма2 * Коэффициент}};
	// КонецЕсли;
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"           // строка (один из Узлы)
		"ЛевыйОперанд,"  // структура (один из #Выражения)
		"Операция,"      // строка (один из Токены)
		"ПравыйОперанд," // структура (один из #Выражения)
		"Место",         // структура (Место)
		Узлы.ВыражениеБинарное, ЛевыйОперанд, Операция, ПравыйОперанд, Место);
КонецФункции // ВыражениеБинарное()

Функция ВыражениеНовый(Имя, Аргументы, Место)
	// Хранит выражение "Новый".
	// Пример:
	// <pre>
	// // выражения "Новый" заключены в скобки {...}
	// // в этом варианте поле "Имя" хранит имя типа "Массив",
	// // а поле "Аргументы" хранит массив из одного выражения
	// Параметры = {Новый Массив(1)};
	// Параметры[0] = 10;
	// // в этом варианте поле "Имя" равно Неопределено,
	// // а поле "Аргументы" хранит массив из двух выражений
	// Массив = <Новый (Тип("Массив"), Параметры)>;
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Имя,"       // неопределено, строка
		"Аргументы," // массив (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ВыражениеНовый, Имя, Аргументы, Место);
КонецФункции // ВыражениеНовый()

Функция ВыражениеТернарное(Выражение, ТогдаОператоры, ИначеОператоры, Хвост, Место)
	// Хранит тернарное выражение "?(,,)".
	// Пример:
	// <pre>
	// Значение = ?(Ложь,   // поле "Выражение"
	//     Неопределено,    // поле "Тогда"
	//     Новый Массив     // поле "Иначе"
	// ).Количество();      // поле "Хвост"
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Тогда,"     // структура (один из #Выражения)
		"Иначе,"     // структура (один из #Выражения)
		"Хвост,"     // массив (ВыражениеПоле, ВыражениеИндекс)
		"Место",     // структура (Место)
		Узлы.ВыражениеТернарное, Выражение, ТогдаОператоры, ИначеОператоры, Хвост, Место);
КонецФункции // ВыражениеТернарное()

Функция ВыражениеСкобочное(Выражение, Место)
	// Хранит скобочное выражение.
	// Пример:
	// <pre>
	// // скобочное выражение заключено в скобки {...}
	// Сумма = {(Сумма1 + Сумма2)} * Количество;
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ВыражениеСкобочное, Выражение, Место);
КонецФункции // ВыражениеСкобочное()

Функция ВыражениеНе(Выражение, Место)
	// Хранит выражение, к которому применено логическое отрицание "Не".
	// Пример:
	// <pre>
	// // выражение-отрицание заключено в скобки {...}
	// НеРавны = {Не Сумма1 = Сумма2};
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ВыражениеНе, Выражение, Место);
КонецФункции // ВыражениеНе()

Функция ВыражениеСтроковое(СписокВыражений, Место)
	// Хранит строковое выражение.
	// Поле "Элементы" хранит упорядоченный список частей строки.
	// Пример:
	// <pre>
	// Строка1 = "Часть1" "Часть2"; // эта строка состоит из двух частей типа Узлы.Строка
	// Строка2 =                    // эта строка состоит из пяти частей типа:
	// "Начало строки               // Узлы.НачалоСтроки
	// | продолжение строки         // Узлы.ПродолжениеСтроки
	// | еще продолжение строки     // Узлы.ПродолжениеСтроки
	// | окончание строки"          // Узлы.ОкончаниеСтроки
	// "еще часть";                 // Узлы.Строка
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"      // строка (один из Узлы)
		"Элементы," // массив (ВыражениеЛитерал)
		"Место",    // структура (Место)
		Узлы.ВыражениеСтроковое, СписокВыражений, Место);
КонецФункции // ВыражениеСтроковое()

#КонецОбласти // Выражения

#Область Операторы

Функция ОператорПрисваивания(ЛевыйОперанд, ПравыйОперанд, Место)
	// Хранит оператор присваивания.
	Возврат Новый Структура( // @Узел
		"Тип,"           // строка (один из Узлы)
		"ЛевыйОперанд,"  // структура (ВыражениеИдентификатор)
		"ПравыйОперанд," // структура (один из #Выражения)
		"Место",         // структура (Место)
		Узлы.ОператорПрисваивания, ЛевыйОперанд, ПравыйОперанд, Место);
КонецФункции // ОператорПрисваивания()

Функция ОператорВозврат(Выражение, Место)
	// Хранит оператор "Возврат".
	// Поле "Выражение" равно Неопределено если это возврат из процедуры.
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // неопределено, структура (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ОператорВозврат, Выражение, Место);
КонецФункции // ОператорВозврат()

Функция ОператорПрервать(Место)
	// Хранит оператор "Прервать".
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Место", // структура (Место)
		Узлы.ОператорПрервать, Место);
КонецФункции // ОператорПрервать()

Функция ОператорПродолжить(Место)
	// Хранит оператор "Продолжить".
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Место", // структура (Место)
		Узлы.ОператорПродолжить, Место);
КонецФункции // ОператорПродолжить()

Функция ОператорВызватьИсключение(Выражение, Место)
	// Хранит оператор "ВызватьИсключение".
	// Поле "Выражение" равно Неопределено если это вариант оператора без выражения.
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // неопределено, структура (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ОператорВызватьИсключение, Выражение, Место);
КонецФункции // ОператорВызватьИсключение()

Функция ОператорВыполнить(Выражение, Место)
	// Хранит оператор "Выполнить".
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Место",     // структура (Место)
		Узлы.ОператорВыполнить, Выражение, Место);
КонецФункции // ОператорВыполнить()

Функция ОператорВызоваПроцедуры(ВыражениеИдентификатор, Место)
	// Хранит вызов процедуры или функции как процедуры.
	Возврат Новый Структура( // @Узел
		"Тип,"           // строка (один из Узлы)
		"Идентификатор," // структура (ВыражениеИдентификатор)
		"Место",         // структура (Место)
		Узлы.ОператорВызоваПроцедуры, ВыражениеИдентификатор, Место);
КонецФункции // ОператорВызоваПроцедуры()

Функция ОператорЕсли(Выражение, Операторы, СписокИначеЕсли, ОператорИначе, Место)
	// Хранит оператор "Если".
	// Пример:
	// <pre>
	// Если Сумма > 0 Тогда // поле "Выражение" хранит условие (выражение)
	//     // поле "Тогда" хранит операторы в этом блоке
	// ИначеЕсли Сумма = 0 Тогда
	//     // поле-массив "ИначеЕсли" хранит последовательность блоков ИначеЕсли
	// Иначе
	//     // поле "Иначе" хранит операторы в этом блоке
	// КонецЕсли
	// </pre>
	// Поля "ИначеЕсли" и "Иначе" равны Неопределено если
	// соответствующие блоки отсутствуют в исходном коде.
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Тогда,"     // массив (один из #Операторы)
		"ИначеЕсли," // неопределено, массив (ОператорИначеЕсли)
		"Иначе,"     // неопределено, структура (ОператорИначе)
		"Место",     // структура (Место)
		Узлы.ОператорЕсли, Выражение, Операторы, СписокИначеЕсли, ОператорИначе, Место);
КонецФункции // ОператорЕсли()

Функция ОператорИначе(Операторы, Место)
	// Хранит блок "Иначе"
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Операторы," // массив (один из #Операторы)
		"Место",     // структура (Место)
		Узлы.ОператорИначе, Операторы, Место);
КонецФункции // ОператорИначе()

Функция ОператорИначеЕсли(Выражение, Операторы, Место)
	// Хранит блок "ИначеЕсли" оператора "Если".
	// Пример:
	// <pre>
	// ...
	// ИначеЕсли Сумма < 0 Тогда // поле "Выражение" хранит условие (выражение)
	//     // поле "Тогда" хранит операторы в этом блоке
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Тогда,"     // массив (один из #Операторы)
		"Место",     // структура (Место)
		Узлы.ОператорИначеЕсли, Выражение, Операторы, Место);
КонецФункции // ОператорИначеЕсли()

Функция ОператорПока(Выражение, Операторы, Место)
	// Хранит оператор цикла "Пока".
	// Пример:
	// <pre>
	// Пока Индекс > 0 Цикл // поле "Выражение" хранит условие (выражение)
	//     // поле "Операторы" хранит операторы в этом блоке
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #Выражения)
		"Операторы," // массив (один из #Операторы)
		"Место",     // структура (Место)
		Узлы.ОператорПока, Выражение, Операторы, Место);
КонецФункции // ОператорПока()

Функция ОператорДля(ВыражениеИдентификатор, Начало, Конец, Операторы, Место)
	// Хранит оператор цикла "Для".
	// Пример:
	// <pre>
	// Для Индекс = 0      // поля "Идентификатор" и "Начало" хранят переменную и выражение инициализации.
	//   По Длина - 1 Цикл // поле "To" хранит выражение границы
	//     // поле "Операторы" хранит операторы в этом блоке
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"           // строка (один из Узлы)
		"Идентификатор," // структура (ВыражениеИдентификатор)
		"Начало,"        // структура (один из #Выражения)
		"Конец,"         // структура (один из #Выражения)
		"Операторы,"     // массив (один из #Операторы)
		"Место",         // структура (Место)
		Узлы.ОператорДля, ВыражениеИдентификатор, Начало, Конец, Операторы, Место);
КонецФункции // ОператорДля()

Функция ОператорДляКаждого(ВыражениеИдентификатор, Коллекция, Операторы, Место)
	// Хранит оператор цикла "Для Каждого".
	// Пример:
	// <pre>
	// Для Каждого Элемент // поле "Идентификатор" хранит переменную.
	//   Из Список Цикл    // поле "Коллекция" хранит выражение коллекции.
	//     // поле "Операторы" хранит операторы в этом блоке
	// КонецЦикла
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"           // строка (один из Узлы)
		"Идентификатор," // структура (ВыражениеИдентификатор)
		"Коллекция,"     // структура (один из #Выражения)
		"Операторы,"     // массив (один из #Операторы)
		"Место",         // структура (Место)
		Узлы.ОператорДляКаждого, ВыражениеИдентификатор, Коллекция, Операторы, Место);
КонецФункции // ОператорДляКаждого()

Функция ОператорПопытка(Операторы, ОператорИсключение, Место)
	// Хранит оператор "Попытка"
	// Пример:
	// <pre>
	// Попытка
	//     // поле "Попытка" хранит операторы в этом блоке.
	// Исключение
	//     // поле "Исключение" хранит операторы в этом блоке
	// КонецПопытки
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"        // строка (один из Узлы)
		"Попытка,"    // массив (один из #Операторы)
		"Исключение," // структура (ОператорИсключение)
		"Место",      // структура (Место)
		Узлы.ОператорПопытка, Операторы, ОператорИсключение, Место);
КонецФункции // ОператорПопытка()

Функция ОператорИсключение(Операторы, Место)
	// Хранит блок "Исключение"
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Операторы," // массив (один из #Операторы)
		"Место",     // структура (Место)
		Узлы.ОператорИсключение, Операторы, Место);
КонецФункции // ОператорИсключение()

Функция ОператорПерейти(Метка, Место)
	// Хранит оператор "Перейти"
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Метка," // строка
		"Место", // структура (Место)
		Узлы.ОператорПерейти, Метка, Место);
КонецФункции // ОператорПерейти()

Функция ОператорМетка(Метка, Место)
	// Хранит оператор метки.
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Метка," // строка
		"Место", // структура (Место)
		Узлы.ОператорМетка, Метка, Место);
КонецФункции // ОператорМетка()

Функция ОператорДобавитьОбработчик(Событие, ОбработчикСобытия, Место)
	// Хранит оператор "ДобавитьОбработчик".
	Возврат Новый Структура( // @Узел
		"Тип,"               // строка (один из Узлы)
		"Событие,"           // структура (ВыражениеИдентификатор)
		"ОбработчикСобытия," // структура (ВыражениеИдентификатор)
		"Место",             // структура (Место)
		Узлы.ОператорДобавитьОбработчик, Событие, ОбработчикСобытия, Место);
КонецФункции // ОператорДобавитьОбработчик()

Функция ОператорУдалитьОбработчик(Событие, ОбработчикСобытия, Место)
	// Хранит оператор "УдалитьОбработчик".
	Возврат Новый Структура( // @Узел
		"Тип,"               // строка (один из Узлы)
		"Событие,"           // структура (ВыражениеИдентификатор)
		"ОбработчикСобытия," // структура (ВыражениеИдентификатор)
		"Место",             // структура (Место)
		Узлы.ОператорУдалитьОбработчик, Событие, ОбработчикСобытия, Место);
КонецФункции // ОператорУдалитьОбработчик()

#КонецОбласти // Операторы

#Область ИнструкцииПрепроцессора

Функция ИнструкцияПрепроцессораЕсли(Выражение, Место)
	// Хранит информацию об инструкции препроцессора #Если,
	// Пример:
	// <pre>
	// ...
	// #Если Сервер Тогда // поле "Выражение" хранит условие (выражение)
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #ВыражениеПрепроцессора)
		"Место",     // структура (Место)
		Узлы.ИнструкцияПрепроцессораЕсли, Выражение, Место);
КонецФункции // ИнструкцияПрепроцессораЕсли()

Функция ИнструкцияПрепроцессораИначеЕсли(Выражение, Место)
	// Хранит информацию об инструкции препроцессора #ИначеЕсли
	// Пример:
	// <pre>
	// ...
	// #ИначеЕсли Клиент Тогда // поле "Выражение" хранит условие (выражение)
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #ВыражениеПрепроцессора)
		"Место",     // структура (Место)
		Узлы.ИнструкцияПрепроцессораИначеЕсли, Выражение, Место);
КонецФункции // ИнструкцияПрепроцессораИначеЕсли()

Функция ИнструкцияПрепроцессораИначе(Место)
	// Хранит информацию об инструкции препроцессора #Иначе
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Место", // структура (Место)
		Узлы.ИнструкцияПрепроцессораИначе, Место);
КонецФункции // ИнструкцияПрепроцессораИначе()

Функция ИнструкцияПрепроцессораКонецЕсли(Место)
	// Хранит информацию об инструкции препроцессора #КонецЕсли
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Место", // структура (Место)
		Узлы.ИнструкцияПрепроцессораКонецЕсли, Место);
КонецФункции // ИнструкцияПрепроцессораКонецЕсли()

Функция ИнструкцияПрепроцессораОбласть(Имя, Место)
	// Хранит информацию об инструкции препроцессора #Обрасть,
	// Пример:
	// <pre>
	// ...
	//#Область Интерфейс   // поле "Имя" хранит имя области
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Имя,"   // строка
		"Место", // структура (Место)
		Узлы.ИнструкцияПрепроцессораОбласть, Имя, Место);
КонецФункции // ИнструкцияПрепроцессораОбласть()

Функция ИнструкцияПрепроцессораКонецОбласти(Место)
	// Хранит информацию об инструкции препроцессора#КонецОбласти,
	// Пример:
	// <pre>
	// ...
	//#КонецОбласти
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"   // строка (один из Узлы)
		"Место", // структура (Место)
		Узлы.ИнструкцияПрепроцессораКонецОбласти, Место);
КонецФункции // ИнструкцияПрепроцессораКонецОбласти()

#КонецОбласти // ИнструкцииПрепроцессора

#Область ВыражениеПрепроцессора

Функция ВыражениеПрепроцессораБинарное(ЛевыйОперанд, Операция, ПравыйОперанд, Место)
	// Хранит бинарное выражение препроцессора.
	// Пример:
	// <pre>
	// // бинарные выражения заключены в скобки {...}
	// // поле "Операция" равно либо Токены.Или либо Токены.И:
	// // поля "ЛевыйОперанд" и "ПравыйОперанд" содержат операнды-выражения препроцессора
	// #Если <Сервер Или ВнешнееСоединение> Тогда
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"           // строка (один из Узлы)
		"ЛевыйОперанд,"  // структура (один из #ВыражениеПрепроцессора)
		"Операция,"      // строка (один из Токены)
		"ПравыйОперанд," // структура (один из #ВыражениеПрепроцессора)
		"Место",         // структура (Место)
		Узлы.ВыражениеПрепроцессораБинарное, ЛевыйОперанд, Операция, ПравыйОперанд, Место);
КонецФункции // ВыражениеПрепроцессораБинарное()

Функция ВыражениеПрепроцессораНе(Выражение, Место)
	// Хранит выражение препроцессора, к которому применено логическое отрицание "Не".
	// Пример:
	// <pre>
	// // выражение-отрицание заключено в скобки {...}
	// #Если <Не ВебКлиент> Тогда
	// ...
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #ВыражениеПрепроцессора)
		"Место",     // структура (Место)
		Узлы.ВыражениеПрепроцессораНе, Выражение, Место);
КонецФункции // ВыражениеПрепроцессораНе()

Функция ВыражениеПрепроцессораСимвол(Символ, Существует, Место)
	// Узел хранит информацию о символе препроцессора.
	// Поле Существует = Истина если такой символ существует.
	// Пример:
	// <pre>
	// // символ заключен в скобки {...}
	// #Если <Сервер> Тогда
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"        // строка (один из Узлы)
		"Символ,"     // строка (один из PrepСимволs)
		"Существует," // булево
		"Место",      // структура (Место)
		Узлы.ВыражениеПрепроцессораСимвол, Символ, Существует, Место);
КонецФункции // ВыражениеПрепроцессораСимвол()

Функция ВыражениеПрепроцессораСкобочное(Выражение, Место)
	// Хранит скобочное выражение препроцессора.
	// Пример:
	// <pre>
	// // скобочное выражение заключено в скобки {...}
	// #Если <(Сервер Или ВнешнееСоединение)> Тогда
	// </pre>
	Возврат Новый Структура( // @Узел
		"Тип,"       // строка (один из Узлы)
		"Выражение," // структура (один из #ВыражениеПрепроцессора)
		"Место",     // структура (Место)
		Узлы.ВыражениеПрепроцессораСкобочное, Выражение, Место);
КонецФункции // ВыражениеПрепроцессораСкобочное()

#КонецОбласти // ВыражениеПрепроцессора

#КонецОбласти // АбстрактноеСинтаксическоеДерево

#Область Парсер

Функция СледующийТокен()
	Перем Начало, ПредыдущийСимвол, Комментарий, Ошибка;

	Парсер_ПозицияКонца = Парсер_ТекущаяПозиция;
	Парсер_НомерПоследнейСтроки = Парсер_НомерТекущейСтроки;

	Парсер_Значение = Неопределено;

	Если Прав(Парсер_Литерал, 1) = Символы_ПС Тогда
		Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
	КонецЕсли;

	Пока Истина Цикл

		Комментарий = Ложь;

		// пропуск невидимых символов
		Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
			Если Парсер_Символ = Символы_ПС Тогда
				Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
			КонецЕсли;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
		КонецЦикла;

		Парсер_ПозицияНачала = Парсер_ТекущаяПозиция;

		Парсер_Токен = КартаТокенов[Парсер_Символ];
		Если Парсер_Токен = Буква Тогда

			// сканирование идентификатора
			Начало = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			КонецЦикла;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);

			// определение токена
			Если КлючевыеСлова.Свойство(Парсер_Литерал, Парсер_Токен) Тогда
				Если Парсер_Токен = Токены.Истина Тогда
					Парсер_Значение = Истина;
				ИначеЕсли Парсер_Токен = Токены.Ложь Тогда
					Парсер_Значение = Ложь;
				ИначеЕсли Парсер_Токен = Токены.Null Тогда
					Парсер_Значение = Null;
				КонецЕсли;
				Если Канон[Парсер_Литерал] <> Истина Тогда
					Ошибка = Парсер_Ошибки.Добавить();
					Ошибка.Текст = СтрШаблон("Неканоничное написание ключевого слова `%1`", Парсер_Литерал);
					Ошибка.НомерСтроки = Парсер_НомерТекущейСтроки;
					Ошибка.Позиция = Парсер_ПозицияНачала;
				КонецЕсли;
			Иначе
				Парсер_Токен = Токены.Идентификатор;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Токены.НачалоСтроки Тогда

			Начало = Парсер_ТекущаяПозиция;
			Парсер_Символ = """"; // уловка
			Пока Парсер_Символ = """" Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Пока Парсер_Символ <> """" И Парсер_Символ <> Символы_ПС И Парсер_Символ <> "" Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;
				Если Парсер_Символ <> "" Тогда
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЕсли;
			КонецЦикла;

			Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);
			Парсер_Значение = СтрЗаменить(Сред(Парсер_Литерал, 2, СтрДлина(Парсер_Литерал) - 2), """""", """");
			Если Прав(Парсер_Литерал, 1) = """" Тогда
				Парсер_Токен = Токены.Строка;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Токены.ПродолжениеСтроки Тогда

			Начало = Парсер_ТекущаяПозиция;
			Парсер_Символ = """"; // уловка
			Пока Парсер_Символ = """" Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Пока Парсер_Символ <> """" И Парсер_Символ <> Символы_ПС И Парсер_Символ <> "" Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;
				Если Парсер_Символ <> "" Тогда
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЕсли;
			КонецЦикла;

			Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);
			Парсер_Значение = СтрЗаменить(Сред(Парсер_Литерал, 2, СтрДлина(Парсер_Литерал) - 2), """""", """");
			Если Прав(Парсер_Литерал, 1) = """" Тогда
				Парсер_Токен = Токены.ОкончаниеСтроки;
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Цифра Тогда

			Начало = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Цифра Цикл
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			КонецЦикла;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			Если Парсер_Символ = "." Тогда
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Цифра Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			КонецЕсли;
			Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);

			Парсер_Значение = Число(Парсер_Литерал);
			Парсер_Токен = Токены.Число;

		ИначеЕсли Парсер_Токен = Токены.ДатаВремя Тогда

			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Начало = Парсер_ТекущаяПозиция;
			Парсер_ТекущаяПозиция = СтрНайти(Парсер_Исходник, "'", , Парсер_ТекущаяПозиция);
			Если Парсер_ТекущаяПозиция = 0 Тогда
				Парсер_Символ = "";
			Иначе
				Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);
				Парсер_Значение = КакДата(Парсер_Литерал);
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
			КонецЕсли;

		ИначеЕсли Парсер_Токен = Неопределено Тогда

			ПредыдущийСимвол = Парсер_Символ;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);

			Если ПредыдущийСимвол = "/" Тогда

				Если Парсер_Символ = "/" Тогда
					// сканирование комментария
					Начало = Парсер_ТекущаяПозиция + 1;
					Если Начало < Парсер_ДлинаИсходника Тогда
						Парсер_ТекущаяПозиция = СтрНайти(Парсер_Исходник, Символы_ПС, , Начало);
						Парсер_Комментарии[Парсер_НомерТекущейСтроки] = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);
					Иначе
						Парсер_ТекущаяПозиция = 0;
					КонецЕсли;
					Если Парсер_ТекущаяПозиция = 0 Тогда
						Парсер_Символ = "";
					Иначе
						Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
					КонецЕсли;
					Комментарий = Истина;
				Иначе
					Парсер_Токен = Токены.ЗнакДеления;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "<" Тогда

				Если Парсер_Символ = ">" Тогда
					Парсер_Токен = Токены.ЗнакНеРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				ИначеЕсли Парсер_Символ = "=" Тогда
					Парсер_Токен = Токены.ЗнакМеньшеИлиРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Иначе
					Парсер_Токен = Токены.ЗнакМеньше;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = ">" Тогда

				Если Парсер_Символ = "=" Тогда
					Парсер_Токен = Токены.ЗнакБольшеИлиРавно;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Иначе
					Парсер_Токен = Токены.ЗнакБольше;
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "&" Тогда

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Буква Тогда
					Ошибка("Ожидалась директива", Парсер_ТекущаяПозиция, Истина);
				КонецЕсли;

				// сканирование идентификатора
				Начало = Парсер_ТекущаяПозиция;
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);

				Если Не Директивы.Свойство(Парсер_Литерал) Тогда
					Ошибка(СтрШаблон("Неизвестная директива: '%1'", Парсер_Литерал));
				КонецЕсли;

				Парсер_Токен = Токены.Директива;

			ИначеЕсли ПредыдущийСимвол = "#" Тогда

				// пропуск невидимых символов
				Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
					Если Парсер_Символ = Символы_ПС Тогда
						Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
					КонецЕсли;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Буква Тогда
					Ошибка("Ожидалась инструкция препроцессора", Парсер_ТекущаяПозиция, Истина);
				КонецЕсли;

				// сканирование идентификатора
				Начало = Парсер_ТекущаяПозиция;
				Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
				КонецЦикла;
				Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);

				// сопоставление токена
				Если ИнструкцииПрепроцессора.Свойство(Парсер_Литерал, Парсер_Токен) Тогда
					Парсер_Токен = "_" + Парсер_Токен;
				Иначе
					Ошибка(СтрШаблон("Неизвестная инструкция препроцессора: '%1'", Парсер_Литерал));
				КонецЕсли;

			ИначеЕсли ПредыдущийСимвол = "~" Тогда

				// пропуск невидимых символов
				Пока ПустаяСтрока(Парсер_Символ) И Парсер_Символ <> "" Цикл
					Если Парсер_Символ = Символы_ПС Тогда
						Парсер_НомерТекущейСтроки = Парсер_НомерТекущейСтроки + 1;
					КонецЕсли;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
				КонецЦикла;

				Если КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] = Неопределено Тогда
					Парсер_Литерал = "";
				Иначе
					// сканирование идентификатора
					Начало = Парсер_ТекущаяПозиция;
					Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					Пока КартаБуквЦифр[Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1)] <> Неопределено Цикл
						Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
					КонецЦикла;
					Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);
					Парсер_Литерал = Сред(Парсер_Исходник, Начало, Парсер_ТекущаяПозиция - Начало);
				КонецЕсли;

				Парсер_Токен = Токены.Метка;

			Иначе

				ВызватьИсключение "Неизвестный символ!";

			КонецЕсли;

		Иначе

			Парсер_Литерал = Парсер_Символ;
			Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;
			Парсер_Символ = Сред(Парсер_Исходник, Парсер_ТекущаяПозиция, 1);

		КонецЕсли;

		Если Не Комментарий Тогда
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Парсер_Токен;

КонецФункции // СледующийТокен()

Функция НайтиЭлементОкружения(Имя)
	Перем Окружение, ЭлементОкружения;
	Окружение = Парсер_Окружение;
	Окружение.Элементы.Свойство(Имя, ЭлементОкружения);
	Пока ЭлементОкружения = Неопределено И Окружение.ВнешнееОкружение <> Неопределено Цикл
		Окружение = Окружение.ВнешнееОкружение;
		Окружение.Элементы.Свойство(Имя, ЭлементОкружения);
	КонецЦикла;
	Возврат ЭлементОкружения;
КонецФункции // НайтиЭлементОкружения()

Функция ОткрытьОкружение()
	Перем Окружение;
	Окружение = Окружение(Парсер_Окружение);
	Парсер_Окружение = Окружение;
	Парсер_Переменные = Окружение.Элементы;
	Возврат Окружение;
КонецФункции // ОткрытьОкружение()

Функция ЗакрытьОкружение()
	Перем Окружение;
	Окружение = Парсер_Окружение.ВнешнееОкружение;
	Парсер_Окружение = Окружение;
	Парсер_Переменные = Окружение.Элементы;
	Возврат Окружение;
КонецФункции // ЗакрытьОкружение()

Функция Контекст() Экспорт
	Возврат Новый Структура("Окружение, Методы", Окружение(Неопределено), Новый Структура);
КонецФункции // Контекст()

Процедура СоздатьМинимальныйКонтекст()
	ОткрытьОкружение();
	// Константы
	ВыставитьПеременную("Chars", "Символы");
	ВыставитьПеременную("SearchDirection", "НаправлениеПоиска");
	ВыставитьПеременную("ThisObject", "ЭтотОбъект");
	// Методы
	ВставитьМетод("Date", "Дата");
	ВставитьМетод("IsBlankString", "ПустаяСтрока");
	ВставитьМетод("Left", "Лев");
	ВставитьМетод("Mid", "Сред");
	ВставитьМетод("Min", "Мин");
	ВставитьМетод("Number", "Число");
	ВставитьМетод("Right", "Прав");
	ВставитьМетод("StrConcat", "СтрСоединить");
	ВставитьМетод("StrFind", "СтрНайти");
	ВставитьМетод("String", "Строка");
	ВставитьМетод("StrLen", "СтрДлина");
	ВставитьМетод("StrSplit", "СтрРазделить");
	ВставитьМетод("StrTemplate", "СтрШаблон");
	ВставитьМетод("TrimAll", "СокрЛП");
	ВставитьМетод("Type", "Тип");
	ВставитьМетод("TypeOf", "ТипЗнч");
КонецПроцедуры // СоздатьМинимальныйКонтекст()

Процедура ВыставитьПеременную(ИмяEn, ИмяRu)
	Парсер_Переменные.Вставить(ИмяEn, ЭлементОкружения(ИмяEn));
	Парсер_Переменные.Вставить(ИмяRu, ЭлементОкружения(ИмяRu));
КонецПроцедуры // ВыставитьПеременную()

Процедура ВставитьМетод(ИмяEn, ИмяRu)
	Парсер_Методы.Вставить(ИмяEn, ЭлементОкружения(ИмяEn));
	Парсер_Методы.Вставить(ИмяRu, ЭлементОкружения(ИмяRu));
КонецПроцедуры // ВставитьМетод()

Функция Токенизировать(Исходник) Экспорт
	Перем Результат, ТаблицаТокенов, НоваяСтрока;

	Парсер_Исходник = Исходник;
	Парсер_ТекущаяПозиция = 0;
	Парсер_НомерТекущейСтроки = 1;
	Парсер_НомерПоследнейСтроки = 1;
	Парсер_ПозицияНачала = 0;
	Парсер_ПозицияКонца = 0;
	Парсер_Комментарии = Новый Соответствие;
	Парсер_ДлинаИсходника = СтрДлина(Исходник);
	Парсер_Литерал = "";
	Парсер_Символ = Неопределено;
	Парсер_Ошибки = Новый ТаблицаЗначений;
	Парсер_Ошибки.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	Парсер_Ошибки.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));

	ТаблицаТокенов = Новый ТаблицаЗначений;
	ТаблицаТокенов.Колонки.Добавить("Токен", Новый ОписаниеТипов("Строка"));
	ТаблицаТокенов.Колонки.Добавить("Литерал", Новый ОписаниеТипов("Строка"));
	ТаблицаТокенов.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
	ТаблицаТокенов.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	ТаблицаТокенов.Колонки.Добавить("Длина", Новый ОписаниеТипов("Число"));

	Пока СледующийТокен() <> Токены.КонецТекста Цикл
		НоваяСтрока = ТаблицаТокенов.Добавить();
		НоваяСтрока.Токен = Парсер_Токен;
		НоваяСтрока.Литерал = Парсер_Литерал;
		НоваяСтрока.НомерСтроки = Парсер_НомерТекущейСтроки;
		НоваяСтрока.Позиция = Парсер_ПозицияНачала;
		НоваяСтрока.Длина = Парсер_ТекущаяПозиция - Парсер_ПозицияНачала;
	КонецЦикла;

	Результат = Новый Структура("Токены, Комментарии", ТаблицаТокенов, Парсер_Комментарии);

	Парсер_Комментарии = Неопределено;

	Возврат Результат;

КонецФункции

Функция Разобрать(Исходник, Контекст = Неопределено) Экспорт
	Перем Объявления, АвтоПеременные, ОбъявлениеАвтоПеременной, ЭлементОкружения, Операторы, Модуль, ТочкиВызова, Место, Ошибка;
	Парсер_Исходник = Исходник;
	Парсер_ТекущаяПозиция = 0;
	Парсер_НомерТекущейСтроки = 1;
	Парсер_НомерПоследнейСтроки = 1;
	Парсер_ПозицияНачала = 0;
	Парсер_ПозицияКонца = 0;
	Парсер_Неизвестные = Новый Структура;
	Парсер_ТочкиВызова = Новый Соответствие;
	Парсер_ЭтоФункция = Ложь;
	Парсер_ПеременныеРазрешены = Истина;
	Парсер_Интерфейс = Новый Массив;
	Парсер_Комментарии = Новый Соответствие;
	Парсер_ДлинаИсходника = СтрДлина(Исходник);
	Парсер_Литерал = "";
	Парсер_Символ = Неопределено;
	Парсер_Ошибки = Новый ТаблицаЗначений;
	Парсер_Ошибки.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	Парсер_Ошибки.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
	Парсер_Ошибки.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	Если Контекст = Неопределено Тогда
		Парсер_Окружение = Неопределено;
		Парсер_Методы = Новый Структура;
		СоздатьМинимальныйКонтекст();
	Иначе
		Парсер_Окружение = Контекст.Окружение;
		Парсер_Методы = Контекст.Методы;
	КонецЕсли;
	ОткрытьОкружение();
	СледующийТокен();
	Объявления = РазобратьОбъявленияМодуля();
	Операторы = РазобратьОператоры();
	АвтоПеременные = Новый Массив;
	Для Каждого ОбъявлениеАвтоПеременной Из Парсер_Окружение.АвтоПеременные Цикл
		АвтоПеременные.Добавить(ОбъявлениеАвтоПеременной);
	КонецЦикла;
	Модуль = Модуль(Объявления, АвтоПеременные, Операторы, Парсер_Интерфейс, Парсер_Комментарии);
	Для Каждого ЭлементОкружения Из Парсер_Неизвестные Цикл
		ТочкиВызова = Парсер_ТочкиВызова[ЭлементОкружения.Значение];
		Для Каждого Место Из ТочкиВызова Цикл
			Ошибка = Парсер_Ошибки.Добавить();
			Ошибка.Текст = СтрШаблон("Метод не объявлен `%1`", ЭлементОкружения.Ключ);
			Ошибка.НомерСтроки = Место.НомерПервойСтроки;
			Ошибка.Позиция = Место.Позиция;
		КонецЦикла;
	КонецЦикла;
	Ожидать(Токены.КонецТекста);
	Парсер_Неизвестные = Неопределено;
	Парсер_Методы = Неопределено;
	Парсер_СписокДиректив = Неопределено;
	Парсер_Интерфейс = Неопределено;
	Парсер_Комментарии = Неопределено;
	Парсер_Окружение = Неопределено;
	Парсер_Переменные = Неопределено;
	Возврат Модуль;
КонецФункции // Разобрать()

Функция Ошибки() Экспорт
	Возврат Парсер_Ошибки;
КонецФункции

Функция Исходник() Экспорт
	Возврат Парсер_Исходник;
КонецФункции

#Область РазборВыражений

Функция РазобратьВыражение()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеИ();
	Пока Парсер_Токен = Токены.Или Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеИ(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражение()

Функция РазобратьВыражениеИ()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеНе();
	Пока Парсер_Токен = Токены.И Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеНе(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеИ()

Функция РазобратьВыражениеНе()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Если Парсер_Токен = Токены.Не Тогда
		СледующийТокен();
		Выражение = ВыражениеНе(
			РазобратьВыражениеОтношения(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	Иначе
		Выражение = РазобратьВыражениеОтношения();
	КонецЕсли;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеНе()

Функция РазобратьВыражениеОтношения()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеАддитивное();
	Пока ОперацииСравнения.Найти(Парсер_Токен) <> Неопределено Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеАддитивное(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеОтношения()

Функция РазобратьВыражениеАддитивное()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеМультипликативное();
	Пока ОперацииАддитивные.Найти(Парсер_Токен) <> Неопределено Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеМультипликативное(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеАддитивное()

Функция РазобратьВыражениеМультипликативное()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеУнарное();
	Пока ОперацииМультипликативные.Найти(Парсер_Токен) <> Неопределено Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеУнарное(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеМультипликативное()

Функция РазобратьВыражениеУнарное()
	Перем Операция, Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Операция = Парсер_Токен;
	Если ОперацииАддитивные.Найти(Парсер_Токен) <> Неопределено Тогда
		СледующийТокен();
		Выражение = ВыражениеУнарное(
			Операция,
			РазобратьОперанд(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	ИначеЕсли Парсер_Токен = Токены.КонецТекста Тогда
		Выражение = Неопределено;
	Иначе
		Выражение = РазобратьОперанд();
	КонецЕсли;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеУнарное()

Функция РазобратьОперанд()
	Перем Токен, Операнд;
	Токен = Парсер_Токен;
	Если Токен = Токены.Строка Или Токен = Токены.НачалоСтроки Тогда
		Операнд = РазобратьВыражениеСтроковое();
	ИначеЕсли ЛитералКромеСтроки.Найти(Токен) <> Неопределено Тогда
		Операнд = ВыражениеЛитерал(
			Токен,
			Парсер_Значение,
			Место(
				Парсер_ПозицияНачала,
				Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
				Парсер_НомерТекущейСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
		СледующийТокен();
	ИначеЕсли Токен = Токены.Идентификатор Тогда
		Операнд = РазобратьВыражениеИдентификатор();
	ИначеЕсли Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Операнд = РазобратьВыражениеСкобочное();
	ИначеЕсли Токен = Токены.Новый Тогда
		Операнд = РазобратьВыражениеНовый();
	ИначеЕсли Токен = Токены.ЗнакВопроса Тогда
		Операнд = РазобратьВыражениеТернарное();
	Иначе
		Ошибка("Ожидался операнд", , Истина);
	КонецЕсли;
	Возврат Операнд;
КонецФункции // РазобратьОперанд()

Функция РазобратьВыражениеСтроковое()
	Перем Токен, СписокВыражений, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Токен = Парсер_Токен;
	СписокВыражений = Новый Массив;
	Пока Истина Цикл
		Если Токен = Токены.Строка Тогда
			СписокВыражений.Добавить(
				ВыражениеЛитерал(
					Токен,
					Парсер_Значение,
					Место(
						Парсер_ПозицияНачала,
						Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
						Парсер_НомерТекущейСтроки,
						Парсер_НомерПоследнейСтроки
					)
				)
			);
			Токен = СледующийТокен();
			Пока Токен = Токены.Строка Цикл
				СписокВыражений.Добавить(
					ВыражениеЛитерал(
						Токен,
						Парсер_Значение,
						Место(
							Парсер_ПозицияНачала,
							Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
							Парсер_НомерТекущейСтроки,
							Парсер_НомерПоследнейСтроки
						)
					)
				);
				Токен = СледующийТокен();
			КонецЦикла;
		ИначеЕсли Токен = Токены.НачалоСтроки Тогда
			СписокВыражений.Добавить(
				ВыражениеЛитерал(
					Токен,
					Парсер_Значение,
					Место(
						Парсер_ПозицияНачала,
						Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
						Парсер_НомерТекущейСтроки,
						Парсер_НомерПоследнейСтроки
					)
				)
			);
			Токен = СледующийТокен();
			Пока Токен = Токены.ПродолжениеСтроки Цикл
				СписокВыражений.Добавить(
					ВыражениеЛитерал(
						Токен,
						Парсер_Значение,
						Место(
							Парсер_ПозицияНачала,
							Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
							Парсер_НомерТекущейСтроки,
							Парсер_НомерПоследнейСтроки
						)
					)
				);
				Токен = СледующийТокен();
			КонецЦикла;
			Если Токен <> Токены.ОкончаниеСтроки Тогда
				Ошибка("Ожидалось """, , Истина);
			КонецЕсли;
			СписокВыражений.Добавить(
				ВыражениеЛитерал(
					Токен,
					Парсер_Значение,
					Место(
						Парсер_ПозицияНачала,
						Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
						Парсер_НомерТекущейСтроки,
						Парсер_НомерПоследнейСтроки
					)
				)
			);
			Токен = СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат ВыражениеСтроковое(
		СписокВыражений,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьВыражениеСтроковое()

Функция РазобратьВыражениеНовый()
	Перем Токен, Имя, Аргументы, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Токен = СледующийТокен();
	Если Токен = Токены.Идентификатор Тогда
		Имя = Парсер_Литерал;
		Аргументы = ПустойМассив;
		Токен = СледующийТокен();
	КонецЕсли;
	Если Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Токен = СледующийТокен();
		Если Токен <> Токены.ПраваяКруглаяСкобка Тогда
			Аргументы = РазобратьАргументы();
			Ожидать(Токены.ПраваяКруглаяСкобка);
		КонецЕсли;
		СледующийТокен();
	КонецЕсли;
	Если Имя = Неопределено И Аргументы = Неопределено Тогда
		Ошибка("Ожидался конструктор", Парсер_ПозицияКонца, Истина);
	КонецЕсли;
	Возврат ВыражениеНовый(
		Имя,
		Аргументы,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьВыражениеНовый()

Функция РазобратьВыражениеИдентификатор(Знач НоваяПеременнаяРазрешена = Ложь, НоваяПеременная = Неопределено, ЭтоВызов = Неопределено)
	Перем Имя, ЭлементОкружения, Хвост, Аргументы, Позиция, НомерСтроки, АвтоПеременныеМесто, ТочкиВызова;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Имя = Парсер_Литерал;
	АвтоПеременныеМесто = Место(
		Парсер_ПозицияНачала,
		Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
		Парсер_НомерТекущейСтроки,
		Парсер_НомерПоследнейСтроки
	);
	СледующийТокен();
	Если Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Если СледующийТокен() = Токены.ПраваяКруглаяСкобка Тогда
			Аргументы = ПустойМассив;
		Иначе
			Аргументы = РазобратьАргументы();
		КонецЕсли;
		Ожидать(Токены.ПраваяКруглаяСкобка);
		СледующийТокен();
		Если Не Парсер_Методы.Свойство(Имя, ЭлементОкружения) Тогда
			Если Парсер_Неизвестные.Свойство(Имя, ЭлементОкружения) Тогда
				ТочкиВызова = Парсер_ТочкиВызова[ЭлементОкружения];
				ТочкиВызова.Добавить(АвтоПеременныеМесто);
			Иначе
				ЭлементОкружения = ЭлементОкружения(Имя);
				Парсер_Неизвестные.Вставить(Имя, ЭлементОкружения);
				ТочкиВызова = Новый Массив;
				ТочкиВызова.Добавить(АвтоПеременныеМесто);
				Парсер_ТочкиВызова[ЭлементОкружения] = ТочкиВызова;
			КонецЕсли;
		КонецЕсли;
		ЭтоВызов = Истина;
		Хвост = РазобратьХвост(ЭтоВызов);
	Иначе
		ЭтоВызов = Ложь;
		Хвост = РазобратьХвост(ЭтоВызов);
		Если Хвост.Количество() > 0 Тогда
			НоваяПеременнаяРазрешена = Ложь;
		КонецЕсли;
		ЭлементОкружения = НайтиЭлементОкружения(Имя);
		Если ЭлементОкружения = Неопределено Тогда
			Если НоваяПеременнаяРазрешена Тогда
				ЭлементОкружения = ЭлементОкружения(Имя, ОбъявлениеАвтоПеременной(Имя, АвтоПеременныеМесто));
				НоваяПеременная = ЭлементОкружения;
			Иначе
				ЭлементОкружения = ЭлементОкружения(Имя);
				Ошибка(СтрШаблон("Не обнаружено объявление идентификатора `%1`", Имя), Позиция);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат ВыражениеИдентификатор(
		ЭлементОкружения,
		Хвост,
		Аргументы,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьВыражениеИдентификатор()

Функция РазобратьХвост(Вызов = Неопределено)
	Перем Хвост, Имя, Аргументы, Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Хвост = Новый Массив;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.Точка Тогда
			СледующийТокен();
			Если КартаБуквЦифр[Лев(Парсер_Литерал, 1)] <> Буква Или Не КлючевыеСлова.Свойство(Парсер_Литерал) Тогда
				Ожидать(Токены.Идентификатор);
			КонецЕсли;
			Имя = Парсер_Литерал;
			Если СледующийТокен() = Токены.ЛеваяКруглаяСкобка Тогда
				Если СледующийТокен() = Токены.ПраваяКруглаяСкобка Тогда
					Аргументы = ПустойМассив;
				Иначе
					Аргументы = РазобратьАргументы();
				КонецЕсли;
				Ожидать(Токены.ПраваяКруглаяСкобка);
				СледующийТокен();
				Вызов = Истина;
			Иначе
				Аргументы = Неопределено;
				Вызов = Ложь;
			КонецЕсли;
			Хвост.Добавить(
				ВыражениеПоле(
					Имя,
					Аргументы,
					Место(
						Позиция,
						Парсер_ПозицияКонца - Позиция,
						НомерСтроки,
						Парсер_НомерПоследнейСтроки
					)
				)
			);
		ИначеЕсли Парсер_Токен = Токены.ЛеваяКвадратнаяСкобка Тогда
			Вызов = Ложь;
			Если СледующийТокен() = Токены.ПраваяКвадратнаяСкобка Тогда
				Ошибка("Ожидалось выражение", Позиция, Истина);
			КонецЕсли;
			Выражение = РазобратьВыражение();
			Ожидать(Токены.ПраваяКвадратнаяСкобка);
			СледующийТокен();
			Хвост.Добавить(
				ВыражениеИндекс(
					Выражение,
					Место(
						Позиция,
						Парсер_ПозицияКонца - Позиция,
						НомерСтроки,
						Парсер_НомерПоследнейСтроки
					)
				)
			);
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат Хвост;
КонецФункции // РазобратьХвост()

Функция РазобратьАргументы()
	Перем СписокВыражений;
	СписокВыражений = Новый Массив;
	Пока Истина Цикл
		Если ТокеныНачалаВыражения.Найти(Парсер_Токен) <> Неопределено Тогда
			СписокВыражений.Добавить(РазобратьВыражение());
		Иначе
			СписокВыражений.Добавить(Неопределено);
		КонецЕсли;
		Если Парсер_Токен = Токены.Запятая Тогда
			СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат СписокВыражений;
КонецФункции // РазобратьАргументы()

Функция РазобратьВыражениеТернарное()
	Перем Выражение, ТогдаОператоры, ИначеОператоры, Хвост, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Ожидать(Токены.ЛеваяКруглаяСкобка);
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.Запятая);
	СледующийТокен();
	ТогдаОператоры = РазобратьВыражение();
	Ожидать(Токены.Запятая);
	СледующийТокен();
	ИначеОператоры = РазобратьВыражение();
	Ожидать(Токены.ПраваяКруглаяСкобка);
	Если СледующийТокен() = Токены.Точка Тогда
		Хвост = РазобратьХвост();
	Иначе
		Хвост = ПустойМассив;
	КонецЕсли;
	Возврат ВыражениеТернарное(
		Выражение,
		ТогдаОператоры,
		ИначеОператоры,
		Хвост,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьВыражениеТернарное()

Функция РазобратьВыражениеСкобочное()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Возврат ВыражениеСкобочное(
		Выражение,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьВыражениеСкобочное()

#КонецОбласти // РазборВыражений

#Область РазборОбъявлений

Функция РазобратьОбъявленияМодуля()
	Перем Объявления;
	Объявления = Новый Массив;
	Пока Истина Цикл
		Парсер_СписокДиректив = Новый Массив;
		Пока Парсер_Токен = Токены.Директива Цикл
			ОбъявлениеДирективы = ОбъявлениеДирективы(
				Директивы[Парсер_Литерал],
				Место(
					Парсер_ПозицияНачала,
					Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
					Парсер_НомерТекущейСтроки,
					Парсер_НомерПоследнейСтроки
				)
			);
			Парсер_СписокДиректив.Добавить(ОбъявлениеДирективы);
			СледующийТокен();
		КонецЦикла;
		Если Парсер_Токен = Токены.Перем И Парсер_ПеременныеРазрешены Тогда
			Объявления.Добавить(РазобратьОбъявлениеСпискаПеременныхМодуля());
		ИначеЕсли Парсер_Токен = Токены.Функция Тогда
			Парсер_ЭтоФункция = Истина;
			Объявления.Добавить(РазобратьОбъявлениеМетода());
			Парсер_ЭтоФункция = Ложь;
			Парсер_ПеременныеРазрешены = Ложь;
		ИначеЕсли Парсер_Токен = Токены.Процедура Тогда
			Объявления.Добавить(РазобратьОбъявлениеМетода());
			Парсер_ПеременныеРазрешены = Ложь;
		ИначеЕсли Парсер_Токен = Токены._Область Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораОбласть());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._КонецОбласти Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораКонецОбласти());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Если Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._ИначеЕсли Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораИначеЕсли());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._Иначе Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораИначе());
			СледующийТокен();
		ИначеЕсли Парсер_Токен = Токены._КонецЕсли Тогда
			Объявления.Добавить(РазобратьИнструкциюПрепроцессораКонецЕсли());
			СледующийТокен();
		Иначе
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	Возврат Объявления;
КонецФункции // РазобратьОбъявленияМодуля()

Функция РазобратьОбъявлениеСпискаПеременныхМодуля()
	Перем ОбъявленияПеременных, Объявление, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	ОбъявленияПеременных = Новый Массив;
	ОбъявленияПеременных.Добавить(РазобратьОбъявлениеПеременнойМодуля());
	Пока Парсер_Токен = Токены.Запятая Цикл
		СледующийТокен();
		ОбъявленияПеременных.Добавить(РазобратьОбъявлениеПеременнойМодуля());
	КонецЦикла;
	Объявление = ОбъявлениеСпискаПеременныхМодуля(
		Парсер_СписокДиректив,
		ОбъявленияПеременных,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
	Ожидать(Токены.ТочкаСЗапятой);
	СледующийТокен();
	Пока Парсер_Токен = Токены.ТочкаСЗапятой Цикл
		СледующийТокен();
	КонецЦикла;
	Возврат Объявление;
КонецФункции // РазобратьОбъявлениеСпискаПеременныхМодуля()

Функция РазобратьОбъявлениеПеременнойМодуля()
	Перем Имя, ОбъявлениеПеременнойМодуля, ЭлементОкружения, ЕстьЭкспорт, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Ожидать(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	Если СледующийТокен() = Токены.Экспорт Тогда
		ЕстьЭкспорт = Истина;
		СледующийТокен();
	Иначе
		ЕстьЭкспорт = Ложь;
	КонецЕсли;
	ОбъявлениеПеременнойМодуля = ОбъявлениеПеременнойМодуля(
		Имя,
		Парсер_СписокДиректив,
		ЕстьЭкспорт,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
	Если Парсер_Переменные.Свойство(Имя) Тогда
		Ошибка("Идентификатор уже объявлен", Позиция, Истина);
	КонецЕсли;
	ЭлементОкружения = ЭлементОкружения(Имя, ОбъявлениеПеременнойМодуля);
	Парсер_Переменные.Вставить(Имя, ЭлементОкружения);
	Если ЕстьЭкспорт Тогда
		Парсер_Интерфейс.Добавить(ЭлементОкружения);
	КонецЕсли;
	Возврат ОбъявлениеПеременнойМодуля;
КонецФункции // РазобратьОбъявлениеПеременнойМодуля()

Функция РазобратьПеременные()
	Перем Токен, Объявления;
	Объявления = Новый Массив;
	Токен = Парсер_Токен;
	Пока Токен = Токены.Перем Цикл
		СледующийТокен();
		Объявления.Добавить(РазобратьОбъявлениеЛокальнойПеременной());
		Пока Парсер_Токен = Токены.Запятая Цикл
			СледующийТокен();
			Объявления.Добавить(РазобратьОбъявлениеЛокальнойПеременной());
		КонецЦикла;
		Ожидать(Токены.ТочкаСЗапятой);
		Токен = СледующийТокен();
	КонецЦикла;
	Возврат Объявления;
КонецФункции // РазобратьПеременные()

Функция РазобратьОбъявлениеЛокальнойПеременной()
	Перем Имя, ОбъявлениеЛокальнойПеременной, Позиция;
	Позиция = Парсер_ПозицияНачала;
	Ожидать(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	ОбъявлениеЛокальнойПеременной = ОбъявлениеЛокальнойПеременной(
		Имя,
		Место(
			Парсер_ПозицияНачала,
			Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
			Парсер_НомерТекущейСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
	Если Парсер_Переменные.Свойство(Имя) Тогда
		Ошибка("Идентификатор уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Переменные.Вставить(Имя, ЭлементОкружения(Имя, ОбъявлениеЛокальнойПеременной));
	СледующийТокен();
	Возврат ОбъявлениеЛокальнойПеременной;
КонецФункции // РазобратьОбъявлениеЛокальнойПеременной()

Функция РазобратьОбъявлениеМетода()
	Перем Сигнатура, ЭлементОкружения, Имя, Переменные, Параметры, ЕстьЭкспорт, Операторы, АвтоПеременные, ОбъявлениеАвтоПеременной, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	ЕстьЭкспорт = Ложь;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	СледующийТокен();
	ОткрытьОкружение();
	Параметры = РазобратьПараметры();
	Если Парсер_Токен = Токены.Экспорт Тогда
		ЕстьЭкспорт = Истина;
		СледующийТокен();
	КонецЕсли;
	Если Парсер_ЭтоФункция Тогда
		Сигнатура = СигнатураФункции(
			Имя,
			Парсер_СписокДиректив,
			Параметры,
			ЕстьЭкспорт,
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	Иначе
		Сигнатура = СигнатураПроцедуры(
			Имя,
			Парсер_СписокДиректив,
			Параметры,
			ЕстьЭкспорт,
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЕсли;
	Если Парсер_Неизвестные.Свойство(Имя, ЭлементОкружения) Тогда
		Парсер_Неизвестные.Удалить(Имя);
		ЭлементОкружения.Объявление = Сигнатура;
	Иначе
		ЭлементОкружения = ЭлементОкружения(Имя, Сигнатура);
	КонецЕсли;
	Если Парсер_Методы.Свойство(Имя) Тогда
		Ошибка("Метод уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Методы.Вставить(Имя, ЭлементОкружения);
	Если ЕстьЭкспорт Тогда
		Парсер_Интерфейс.Добавить(ЭлементОкружения);
	КонецЕсли;
	Переменные = РазобратьПеременные();
	Операторы = РазобратьОператоры();
	Если Парсер_ЭтоФункция Тогда
		Ожидать(Токены.КонецФункции);
	Иначе
		Ожидать(Токены.КонецПроцедуры);
	КонецЕсли;
	АвтоПеременные = Новый Массив;
	Для Каждого ОбъявлениеАвтоПеременной Из Парсер_Окружение.АвтоПеременные Цикл
		АвтоПеременные.Добавить(ОбъявлениеАвтоПеременной);
	КонецЦикла;
	ЗакрытьОкружение();
	СледующийТокен();
	Возврат ОбъявлениеМетода(
		Сигнатура,
		Переменные,
		АвтоПеременные,
		Операторы,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОбъявлениеМетода()

Функция РазобратьПараметры()
	Перем Параметры;
	Ожидать(Токены.ЛеваяКруглаяСкобка);
	СледующийТокен();
	Если Парсер_Токен = Токены.ПраваяКруглаяСкобка Тогда
		Параметры = ПустойМассив;
	Иначе
		Параметры = Новый Массив;
		Параметры.Добавить(РазобратьОбъявлениеПараметра());
		Пока Парсер_Токен = Токены.Запятая Цикл
			СледующийТокен();
			Параметры.Добавить(РазобратьОбъявлениеПараметра());
		КонецЦикла;
	КонецЕсли;
	Ожидать(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Возврат Параметры;
КонецФункции // РазобратьПараметры()

Функция РазобратьОбъявлениеПараметра()
	Перем Имя, ОбъявлениеПараметра, ПоЗначению, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Если Парсер_Токен = Токены.Знач Тогда
		ПоЗначению = Истина;
		СледующийТокен();
	Иначе
		ПоЗначению = Ложь;
	КонецЕсли;
	Ожидать(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	Если СледующийТокен() = Токены.ЗнакРавно Тогда
		СледующийТокен();
		ОбъявлениеПараметра = ОбъявлениеПараметра(
			Имя,
			ПоЗначению,
			РазобратьВыражениеУнарное(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	Иначе
		ОбъявлениеПараметра = ОбъявлениеПараметра(
			Имя,
			ПоЗначению,
			Неопределено,
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЕсли;
	Если Парсер_Переменные.Свойство(Имя) Тогда
		Ошибка("Идентификатор уже объявлен", Позиция, Истина);
	КонецЕсли;
	Парсер_Переменные.Вставить(Имя, ЭлементОкружения(Имя, ОбъявлениеПараметра));
	Возврат ОбъявлениеПараметра;
КонецФункции // РазобратьОбъявлениеПараметра()

#КонецОбласти // РазборОбъявлений

#Область РазборОператоров

Функция РазобратьОператоры()
	Перем Операторы, Оператор;
	Операторы = Новый Массив;
	Оператор = РазобратьОператор();
	Если Оператор <> Неопределено Тогда
		Операторы.Добавить(Оператор);
	КонецЕсли;
	Пока Истина Цикл
		Если Парсер_Токен = Токены.ТочкаСЗапятой Тогда
			СледующийТокен();
		ИначеЕсли Лев(Парсер_Токен, 1) <> "_" Тогда // если не препроцессор
			Прервать;
		КонецЕсли;
		Оператор = РазобратьОператор();
		Если Оператор <> Неопределено Тогда
			Операторы.Добавить(Оператор);
		КонецЕсли;
	КонецЦикла;
	Возврат Операторы;
КонецФункции // РазобратьОператоры()

Функция РазобратьОператор()
	Перем Токен, Оператор;
	Токен = Парсер_Токен;
	Если Токен = Токены.Идентификатор Тогда
		Оператор = РазобратьОператорПрисваиванияИлиВызоваПроцедуры();
	ИначеЕсли Токен = Токены.Если Тогда
		Оператор = РазобратьОператорЕсли();
	ИначеЕсли Токен = Токены.Попытка Тогда
		Оператор = РазобратьОператорПопытка();
	ИначеЕсли Токен = Токены.Пока Тогда
		Оператор = РазобратьОператорПока();
	ИначеЕсли Токен = Токены.Для Тогда
		Если СледующийТокен() = Токены.Каждого Тогда
			Оператор = РазобратьОператорДляКаждого();
		Иначе
			Оператор = РазобратьОператорДля();
		КонецЕсли;
	ИначеЕсли Токен = Токены.Возврат Тогда
		Оператор = РазобратьОператорВозврат();
	ИначеЕсли Токен = Токены.Прервать Тогда
		Оператор = РазобратьОператорПрервать();
	ИначеЕсли Токен = Токены.Продолжить Тогда
		Оператор = РазобратьОператорПродолжить();
	ИначеЕсли Токен = Токены.ВызватьИсключение Тогда
		Оператор = РазобратьОператорВызватьИсключение();
	ИначеЕсли Токен = Токены.Выполнить Тогда
		Оператор = РазобратьОператорВыполнить();
	ИначеЕсли Токен = Токены.Перейти Тогда
		Оператор = РазобратьОператорПерейти();
	ИначеЕсли Токен = Токены.Метка Тогда
		Оператор = РазобратьОператорМетка();
	ИначеЕсли Токен = Токены.ДобавитьОбработчик Тогда
		Оператор = РазобратьОператорДобавитьОбработчик();
	ИначеЕсли Токен = Токены.УдалитьОбработчик Тогда
		Оператор = РазобратьОператорУдалитьОбработчик();
	ИначеЕсли Токен = Токены._Область Тогда
		Оператор = РазобратьИнструкциюПрепроцессораОбласть();
	ИначеЕсли Токен = Токены._КонецОбласти Тогда
		Оператор = РазобратьИнструкциюПрепроцессораКонецОбласти();
	ИначеЕсли Токен = Токены._Если Тогда
		Оператор = РазобратьИнструкциюПрепроцессораЕсли();
	ИначеЕсли Токен = Токены._ИначеЕсли Тогда
		Оператор = РазобратьИнструкциюПрепроцессораИначеЕсли();
	ИначеЕсли Токен = Токены._Иначе Тогда
		Оператор = РазобратьИнструкциюПрепроцессораИначе();
	ИначеЕсли Токен = Токены._КонецЕсли Тогда
		Оператор = РазобратьИнструкциюПрепроцессораКонецЕсли();
	ИначеЕсли Токен = Токены.ТочкаСЗапятой Тогда
		// NOP
	КонецЕсли;
	Возврат Оператор;
КонецФункции // РазобратьОператор()

Функция РазобратьОператорВызватьИсключение()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Если ТокеныНачалаВыражения.Найти(СледующийТокен()) <> Неопределено Тогда
		Выражение = РазобратьВыражение();
	КонецЕсли;
	Возврат ОператорВызватьИсключение(
		Выражение,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорВызватьИсключение()

Функция РазобратьОператорВыполнить()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Возврат ОператорВыполнить(
		РазобратьВыражение(),
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорВыполнить()

Функция РазобратьОператорПрисваиванияИлиВызоваПроцедуры()
	Перем ЛевыйОперанд, ЭтоВызов, ПравыйОперанд, Оператор, НоваяПеременная, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	ЛевыйОперанд = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, ЭтоВызов);
	Если ЭтоВызов Тогда
		Оператор = ОператорВызоваПроцедуры(
			ЛевыйОперанд,
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	Иначе
		Ожидать(Токены.ЗнакРавно);
		СледующийТокен();
		ПравыйОперанд = РазобратьВыражение();
		Если НоваяПеременная <> Неопределено Тогда
			Парсер_Переменные.Вставить(НоваяПеременная.Имя, НоваяПеременная);
			Парсер_Окружение.АвтоПеременные.Добавить(НоваяПеременная.Объявление);
		КонецЕсли;
		Оператор = ОператорПрисваивания(
			ЛевыйОперанд,
			ПравыйОперанд,
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЕсли;
	Возврат Оператор;
КонецФункции // РазобратьОператорПрисваиванияИлиВызоваПроцедуры()

Функция РазобратьОператорЕсли()
	Перем Выражение, ТогдаОператоры, ОператорИначе, СписокИначеЕсли, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.Тогда);
	СледующийТокен();
	ТогдаОператоры = РазобратьОператоры();
	Если Парсер_Токен = Токены.ИначеЕсли Тогда
		СписокИначеЕсли = Новый Массив;
		Пока Парсер_Токен = Токены.ИначеЕсли Цикл
			СписокИначеЕсли.Добавить(РазобратьОператорИначеЕсли());
		КонецЦикла;
	КонецЕсли;
	Если Парсер_Токен = Токены.Иначе Тогда
		ОператорИначе = РазобратьОператорИначе();
	КонецЕсли;
	Ожидать(Токены.КонецЕсли);
	СледующийТокен();
	Возврат ОператорЕсли(
		Выражение,
		ТогдаОператоры,
		СписокИначеЕсли,
		ОператорИначе,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорЕсли()

Функция РазобратьОператорИначеЕсли()
	Перем ЕслиВыражение, ТогдаОператоры, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	ЕслиВыражение = РазобратьВыражение();
	Ожидать(Токены.Тогда);
	СледующийТокен();
	ТогдаОператоры = РазобратьОператоры();
	Возврат ОператорИначеЕсли(
		ЕслиВыражение,
		ТогдаОператоры,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорИначеЕсли()

Функция РазобратьОператорИначе()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Возврат ОператорИначе(
		РазобратьОператоры(),
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорИначе()

Функция РазобратьОператорПопытка()
	Перем Операторы, ОператорИсключение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.Исключение);
	ОператорИсключение = РазобратьОператорИсключение();
	Ожидать(Токены.КонецПопытки);
	СледующийТокен();
	Возврат ОператорПопытка(
		Операторы,
		ОператорИсключение,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорПопытка()

Функция РазобратьОператорИсключение()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Возврат ОператорИсключение(
		РазобратьОператоры(),
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорИсключение()

Функция РазобратьОператорПока()
	Перем Выражение, Операторы, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражение();
	Ожидать(Токены.Цикл);
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.КонецЦикла);
	СледующийТокен();
	Возврат ОператорПока(
		Выражение,
		Операторы,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорПока()

Функция РазобратьОператорДля()
	Перем ВыражениеИдентификатор, ЭтоВызов, Начало, Конец, Операторы, ПозицияПеременной, НоваяПеременная, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Ожидать(Токены.Идентификатор);
	ПозицияПеременной = Парсер_ПозицияНачала;
	ВыражениеИдентификатор = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка("Ожидалась переменная", ПозицияПеременной, Истина);
	КонецЕсли;
	Ожидать(Токены.ЗнакРавно);
	СледующийТокен();
	Начало = РазобратьВыражение();
	Ожидать(Токены.По);
	СледующийТокен();
	Конец = РазобратьВыражение();
	Если НоваяПеременная <> Неопределено Тогда
		Парсер_Переменные.Вставить(НоваяПеременная.Имя, НоваяПеременная);
		Парсер_Окружение.АвтоПеременные.Добавить(НоваяПеременная.Объявление);
	КонецЕсли;
	Ожидать(Токены.Цикл);
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.КонецЦикла);
	СледующийТокен();
	Возврат ОператорДля(
		ВыражениеИдентификатор,
		Начало,
		Конец,
		Операторы,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорДля()

Функция РазобратьОператорДляКаждого()
	Перем ВыражениеИдентификатор, ЭтоВызов, Коллекция, Операторы, ПозицияПеременной, НоваяПеременная, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	ПозицияПеременной = Парсер_ПозицияНачала;
	ВыражениеИдентификатор = РазобратьВыражениеИдентификатор(Истина, НоваяПеременная, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка("Ожидалась переменная", ПозицияПеременной, Истина);
	КонецЕсли;
	Ожидать(Токены.Из);
	СледующийТокен();
	Коллекция = РазобратьВыражение();
	Если НоваяПеременная <> Неопределено Тогда
		Парсер_Переменные.Вставить(НоваяПеременная.Имя, НоваяПеременная);
		Парсер_Окружение.АвтоПеременные.Добавить(НоваяПеременная.Объявление);
	КонецЕсли;
	Ожидать(Токены.Цикл);
	СледующийТокен();
	Операторы = РазобратьОператоры();
	Ожидать(Токены.КонецЦикла);
	СледующийТокен();
	Возврат ОператорДляКаждого(
		ВыражениеИдентификатор,
		Коллекция,
		Операторы,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорДляКаждого()

Функция РазобратьОператорПерейти()
	Перем Метка, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Ожидать(Токены.Метка);
	Метка = Парсер_Литерал;
	СледующийТокен();
	Возврат ОператорПерейти(
		Метка,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорПерейти()

Функция РазобратьОператорВозврат()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Если Парсер_ЭтоФункция Тогда
		Выражение = РазобратьВыражение();
	КонецЕсли;
	Возврат ОператорВозврат(
		Выражение,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорВозврат()

Функция РазобратьОператорПрервать()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Возврат ОператорПрервать(
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорПрервать()

Функция РазобратьОператорПродолжить()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Возврат ОператорПродолжить(
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорПродолжить()

Функция РазобратьОператорМетка()
	Перем Позиция, НомерСтроки, Метка;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Метка = Парсер_Литерал;
	СледующийТокен();
	Ожидать(Токены.Двоеточие);
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Возврат ОператорМетка(
		Метка,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорМетка()

Функция РазобратьОператорДобавитьОбработчик()
	Перем Событие, ОбработчикСобытия, ЭтоВызов, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Событие = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка("Имя события указано неправильно", Позиция, Истина);
	КонецЕсли;
	Ожидать(Токены.Запятая);
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	ОбработчикСобытия = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка("Имя метода указано неправильно", Позиция, Истина);
	КонецЕсли;
	Возврат ОператорДобавитьОбработчик(
		Событие,
		ОбработчикСобытия,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорДобавитьОбработчик()

Функция РазобратьОператорУдалитьОбработчик()
	Перем Событие, ОбработчикСобытия, ЭтоВызов, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Событие = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка("Имя события указано неправильно", Позиция, Истина);
	КонецЕсли;
	Ожидать(Токены.Запятая);
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	ОбработчикСобытия = РазобратьВыражениеИдентификатор(Ложь, Неопределено, ЭтоВызов);
	Если ЭтоВызов Тогда
		Ошибка("Имя метода указано неправильно", Позиция, Истина);
	КонецЕсли;
	Возврат ОператорУдалитьОбработчик(
		Событие,
		ОбработчикСобытия,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьОператорУдалитьОбработчик()

#КонецОбласти // РазборОператоров

#Область РазборПрепроцессора

 // Выражения

Функция РазобратьВыражениеПрепроцессора()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеПрепроцессораИ();
	Пока Парсер_Токен = Токены.Или Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеПрепроцессораБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеПрепроцессораИ(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеПрепроцессора()

Функция РазобратьВыражениеПрепроцессораИ()
	Перем Выражение, Операция, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Выражение = РазобратьВыражениеПрепроцессораНе();
	Пока Парсер_Токен = Токены.И Цикл
		Операция = Парсер_Токен;
		СледующийТокен();
		Выражение = ВыражениеПрепроцессораБинарное(
			Выражение,
			Операция,
			РазобратьВыражениеПрепроцессораНе(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	КонецЦикла;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеПрепроцессораИ()

Функция РазобратьВыражениеПрепроцессораНе()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Если Парсер_Токен = Токены.Не Тогда
		СледующийТокен();
		Выражение = ВыражениеПрепроцессораНе(
			РазобратьВыражениеПрепроцессораОперанд(),
			Место(
				Позиция,
				Парсер_ПозицияКонца - Позиция,
				НомерСтроки,
				Парсер_НомерПоследнейСтроки
			)
		);
	Иначе
		Выражение = РазобратьВыражениеПрепроцессораОперанд();
	КонецЕсли;
	Возврат Выражение;
КонецФункции // РазобратьВыражениеПрепроцессораНе()

Функция РазобратьВыражениеПрепроцессораОперанд()
	Перем Операнд;
	Если Парсер_Токен = Токены.Идентификатор Тогда
		Операнд = РазобратьВыражениеПрепроцессораСимвол();
	ИначеЕсли Парсер_Токен = Токены.ЛеваяКруглаяСкобка Тогда
		Операнд = РазобратьВыражениеПрепроцессораСкобочное();
	Иначе
		Ошибка("Ожидался символ препроцессора", , Истина);
	КонецЕсли;
	Возврат Операнд;
КонецФункции

Функция РазобратьВыражениеПрепроцессораСимвол()
	Перем Символ, СимволСуществует;
	СимволСуществует = СимволыПрепроцессора.Свойство(Парсер_Литерал);
	Символ = ВыражениеПрепроцессораСимвол(
		Парсер_Литерал,
		СимволСуществует,
		Место(
			Парсер_ПозицияНачала,
			Парсер_ТекущаяПозиция - Парсер_ПозицияНачала,
			Парсер_НомерТекущейСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
	СледующийТокен();
	Возврат Символ;
КонецФункции // РазобратьВыражениеПрепроцессораСимвол()

Функция РазобратьВыражениеПрепроцессораСкобочное()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражениеПрепроцессора();
	Ожидать(Токены.ПраваяКруглаяСкобка);
	СледующийТокен();
	Возврат ВыражениеПрепроцессораСкобочное(
		Выражение,
		Место(
			Позиция,
			Парсер_ПозицияКонца - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьВыражениеПрепроцессораСкобочное()

// Инструкции

Функция РазобратьИнструкциюПрепроцессораЕсли()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражениеПрепроцессора();
	Ожидать(Токены.Тогда);
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Возврат ИнструкцияПрепроцессораЕсли(
		Выражение,
		Место(
			Позиция,
			Парсер_ТекущаяПозиция - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьИнструкциюПрепроцессораЕсли()

Функция РазобратьИнструкциюПрепроцессораИначеЕсли()
	Перем Выражение, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Выражение = РазобратьВыражениеПрепроцессора();
	Ожидать(Токены.Тогда);
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Возврат ИнструкцияПрепроцессораИначеЕсли(
		Выражение,
		Место(
			Позиция,
			Парсер_ТекущаяПозиция - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьИнструкциюПрепроцессораИначеЕсли()

Функция РазобратьИнструкциюПрепроцессораИначе()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Парсер_НомерПоследнейСтроки = Парсер_НомерТекущейСтроки; // уловка
	Возврат ИнструкцияПрепроцессораИначе(
		Место(
			Позиция,
			Парсер_ТекущаяПозиция - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьИнструкциюПрепроцессораИначе()

Функция РазобратьИнструкциюПрепроцессораКонецЕсли()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Парсер_НомерПоследнейСтроки = Парсер_НомерТекущейСтроки; // уловка
	Возврат ИнструкцияПрепроцессораКонецЕсли(
		Место(
			Позиция,
			Парсер_ТекущаяПозиция - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьИнструкциюПрепроцессораКонецЕсли()

Функция РазобратьИнструкциюПрепроцессораОбласть()
	Перем Имя, Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	СледующийТокен();
	Ожидать(Токены.Идентификатор);
	Имя = Парсер_Литерал;
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Возврат ИнструкцияПрепроцессораОбласть(
		Имя,
		Место(
			Позиция,
			Парсер_ТекущаяПозиция - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьИнструкциюПрепроцессораОбласть()

Функция РазобратьИнструкциюПрепроцессораКонецОбласти()
	Перем Позиция, НомерСтроки;
	Позиция = Парсер_ПозицияНачала;
	НомерСтроки = Парсер_НомерТекущейСтроки;
	Парсер_Токен = Токены.ТочкаСЗапятой; // уловка
	Парсер_НомерПоследнейСтроки = Парсер_НомерТекущейСтроки; // уловка
	Возврат ИнструкцияПрепроцессораКонецОбласти(
		Место(
			Позиция,
			Парсер_ТекущаяПозиция - Позиция,
			НомерСтроки,
			Парсер_НомерПоследнейСтроки
		)
	);
КонецФункции // РазобратьИнструкциюПрепроцессораКонецОбласти()

#КонецОбласти // РазборПрепроцессора

#КонецОбласти // Парсер

#Область СлужебныеМетоды

Функция Место(Позиция, Длина, НомерПервойСтроки, НомерПоследнейСтроки)
	Возврат Новый Структура(
		"Позиция," // число
		"Длина," // число
		"НомерПервойСтроки," // число
		"НомерПоследнейСтроки",  // число
		Позиция, Длина, НомерПервойСтроки, НомерПоследнейСтроки);
КонецФункции // Место()

Функция КакДата(ЛитералДаты)
	Перем Список, Символ, Позиция, ДатаСтрокой;
	Список = Новый Массив;
	Для Позиция = 1 По СтрДлина(ЛитералДаты) Цикл
		Символ = Сред(ЛитералДаты, Позиция, 1);
		Если КартаБуквЦифр[Символ] = Цифра Тогда
			Список.Добавить(Символ);
		КонецЕсли;
	КонецЦикла;
	ДатаСтрокой = СтрСоединить(Список);
	Если ДатаСтрокой = "00000000"
	Или ДатаСтрокой = "000000000000"
	Или ДатаСтрокой = "00000000000000" Тогда
		Возврат '00010101';
	КонецЕсли;
	Попытка
		Дата = Дата(ДатаСтрокой);
	Исключение
		Ошибка(СтрШаблон("Ошибка в литерале даты `%1`", ЛитералДаты), Парсер_ТекущаяПозиция - СтрДлина(ЛитералДаты), Истина);
	КонецПопытки;
	Возврат Дата;
КонецФункции // КакДата()

Процедура Ожидать(Токен)
	Если Парсер_Токен <> Токен Тогда
		Ошибка("Ожидалось " + Токен, Парсер_ПозицияНачала, Истина);
	КонецЕсли;
КонецПроцедуры // Ожидать()

Процедура Ошибка(Текст, Позиция = Неопределено, Остановить = Ложь)
	Перем Ошибка;
	Если Позиция = Неопределено Тогда
		Позиция = Мин(Парсер_ТекущаяПозиция - СтрДлина(Парсер_Литерал), Парсер_ДлинаИсходника);
	КонецЕсли;
	Ошибка = Парсер_Ошибки.Добавить();
	Ошибка.Текст = Текст;
	Ошибка.НомерСтроки = Парсер_НомерТекущейСтроки;
	Ошибка.Позиция = Позиция;
	Если Остановить Тогда
		ВызватьИсключение Текст;
	КонецЕсли;
КонецПроцедуры // Ошибка()

#КонецОбласти // СлужебныеМетоды

#Область Посетитель

Процедура Подключить(Знач Плагины) Экспорт
	Перем Плагин, Список, ИмяПроцедуры;
	Если ТипЗнч(Плагины) <> Тип("Массив") Тогда
		Плагин = Плагины;
		Плагины = Новый Массив;
		Плагины.Добавить(Плагин);
	КонецЕсли;
	Посетитель_Плагины = Плагины;
	Посетитель_Подписки = Подписки();
	Для Каждого Плагин Из Плагины Цикл
		Список = Неопределено;
		Для Каждого ИмяПроцедуры Из Плагин.Подписки() Цикл
			Если Посетитель_Подписки.Свойство(ИмяПроцедуры, Список) Тогда
				Список.Добавить(Плагин);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры // Подключить()

Процедура ДобавитьНаСтек(Родитель)
	Перем ТипУзла;
	Посетитель_Стек = Новый ФиксированнаяСтруктура("Внешний, Родитель", Посетитель_Стек, Родитель);
	ТипУзла = Родитель.Тип;
	Посетитель_Счетчики[ТипУзла] = Посетитель_Счетчики[ТипУзла] + 1;
КонецПроцедуры // ДобавитьНаСтек()

Процедура СнятьСоСтека()
	Перем ТипУзла;
	ТипУзла = Посетитель_Стек.Родитель.Тип;
	Посетитель_Счетчики[ТипУзла] = Посетитель_Счетчики[ТипУзла] - 1;
	Посетитель_Стек = Посетитель_Стек.Внешний;
КонецПроцедуры // СнятьСоСтека()

Функция Подписки()
	Перем Подписки, Элемент;

	Подписки = Новый Структура(
		"ПосетитьМодуль,                           ПокинутьМодуль,"
		"ПосетитьОбъявления,                       ПокинутьОбъявления,"
		"ПосетитьОператоры,                        ПокинутьОператоры,"
		"ПосетитьОбъявление,                       ПокинутьОбъявление,"
		"ПосетитьОбъявлениеСпискаПеременныхМодуля, ПокинутьОбъявлениеСпискаПеременныхМодуля,"
		"ПосетитьОбъявлениеПеременнойМодуля,       ПокинутьОбъявлениеПеременнойМодуля,"
		"ПосетитьОбъявлениеЛокальнойПеременной,    ПокинутьОбъявлениеЛокальнойПеременной,"
		"ПосетитьОбъявлениеПараметра,              ПокинутьОбъявлениеПараметра,"
		"ПосетитьОбъявлениеМетода,                 ПокинутьОбъявлениеМетода,"
		"ПосетитьСигнатуру,                        ПокинутьСигнатуру,"
		"ПосетитьВыражение,                        ПокинутьВыражение,"
		"ПосетитьВыражениеЛитерал,                 ПокинутьВыражениеЛитерал,"
		"ПосетитьВыражениеИдентификатор,           ПокинутьВыражениеИдентификатор,"
		"ПосетитьВыражениеУнарное,                 ПокинутьВыражениеУнарное,"
		"ПосетитьВыражениеБинарное,                ПокинутьВыражениеБинарное,"
		"ПосетитьВыражениеНовый,                   ПокинутьВыражениеНовый,"
		"ПосетитьВыражениеТернарное,               ПокинутьВыражениеТернарное,"
		"ПосетитьВыражениеСкобочное,               ПокинутьВыражениеСкобочное,"
		"ПосетитьВыражениеНе,                      ПокинутьВыражениеНе,"
		"ПосетитьВыражениеСтроковое,               ПокинутьВыражениеСтроковое,"
		"ПосетитьОператор,                         ПокинутьОператор,"
		"ПосетитьОператорПрисваивания,             ПокинутьОператорПрисваивания,"
		"ПосетитьОператорВозврат,                  ПокинутьОператорВозврат,"
		"ПосетитьОператорПрервать,                 ПокинутьОператорПрервать,"
		"ПосетитьОператорПродолжить,               ПокинутьОператорПродолжить,"
		"ПосетитьОператорВызватьИсключение,        ПокинутьОператорВызватьИсключение,"
		"ПосетитьОператорВыполнить,                ПокинутьОператорВыполнить,"
		"ПосетитьОператорВызоваПроцедуры,          ПокинутьОператорВызоваПроцедуры,"
		"ПосетитьОператорЕсли,                     ПокинутьОператорЕсли,"
		"ПосетитьОператорИначеЕсли,                ПокинутьОператорИначеЕсли,"
		"ПосетитьОператорИначе,                    ПокинутьОператорИначе,"
		"ПосетитьОператорПока,                     ПокинутьОператорПока,"
		"ПосетитьОператорДля,                      ПокинутьОператорДля,"
		"ПосетитьОператорДляКаждого,               ПокинутьОператорДляКаждого,"
		"ПосетитьОператорПопытка,                  ПокинутьОператорПопытка,"
		"ПосетитьОператорИсключение,               ПокинутьОператорИсключение,"
		"ПосетитьОператорПерейти,                  ПокинутьОператорПерейти,"
		"ПосетитьОператорМетка,                    ПокинутьОператорМетка,"
		"ПосетитьОператорДобавитьОбработчик,       ПокинутьОператорДобавитьОбработчик,"
		"ПосетитьОператорУдалитьОбработчик,        ПокинутьОператорУдалитьОбработчик,"
		"ПосетитьИнструкциюПрепроцессора,          ПокинутьИнструкциюПрепроцессора,"
		"ПосетитьВыражениеПрепроцессора,           ПокинутьВыражениеПрепроцессора,"
		"ПосетитьВыражениеПрепроцессораБинарное,   ПокинутьВыражениеПрепроцессораБинарное,"
		"ПосетитьВыражениеПрепроцессораНе,         ПокинутьВыражениеПрепроцессораНе,"
		"ПосетитьВыражениеПрепроцессораСимвол,     ПокинутьВыражениеПрепроцессораСимвол,"
		"ПосетитьВыражениеПрепроцессораСкобочное,  ПокинутьВыражениеПрепроцессораСкобочное"
	);
	Для Каждого Элемент Из Подписки Цикл
		Подписки[Элемент.Ключ] = Новый Массив;
	КонецЦикла;

	Возврат Подписки;

КонецФункции // Подписки()

Процедура Посетить(Модуль) Экспорт
	Перем Плагин, Подписка, Элемент;
	Для Каждого Плагин Из Посетитель_Плагины Цикл
		Плагин.Инициализировать(ЭтотОбъект);
	КонецЦикла;
	Посетитель_Стек = Новый ФиксированнаяСтруктура("Внешний, Родитель", Неопределено, Неопределено);
	Посетитель_Счетчики = Новый Структура;
	Для Каждого Элемент Из Узлы Цикл
		Посетитель_Счетчики.Вставить(Элемент.Ключ, 0);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьМодуль Цикл
		Подписка.ПосетитьМодуль(Модуль, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(Модуль);
	ПосетитьОбъявления(Модуль.Объявления);
	ПосетитьОператоры(Модуль.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьМодуль Цикл
		Подписка.ПокинутьМодуль(Модуль, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // Посетить()

Процедура ПосетитьОбъявления(Объявления)
	Перем Объявление, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявления Цикл
		Подписка.ПосетитьОбъявления(Объявления, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Объявление Из Объявления Цикл
		ПосетитьОбъявление(Объявление);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявления Цикл
		Подписка.ПокинутьОбъявления(Объявления, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявления()

Процедура ПосетитьОператоры(Операторы)
	Перем Оператор, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператоры Цикл
		Подписка.ПосетитьОператоры(Операторы, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Оператор Из Операторы Цикл
		ПосетитьОператор(Оператор);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператоры Цикл
		Подписка.ПокинутьОператоры(Операторы, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператоры()

#Область ПосещениеОбъявлений

Процедура ПосетитьОбъявление(Объявление)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявление Цикл
		Подписка.ПосетитьОбъявление(Объявление, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = Объявление.Тип;
	Если Тип = Узлы.ОбъявлениеСпискаПеременныхМодуля Тогда
		ПосетитьОбъявлениеСпискаПеременныхМодуля(Объявление);
	ИначеЕсли Тип = Узлы.ОбъявлениеЛокальнойПеременной Тогда
		ПосетитьОбъявлениеЛокальнойПеременной(Объявление);
	ИначеЕсли Тип = Узлы.ОбъявлениеМетода Тогда
		ПосетитьОбъявлениеМетода(Объявление);
	ИначеЕсли Тип = Узлы.ИнструкцияПрепроцессораОбласть
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецОбласти
		Или Тип = Узлы.ИнструкцияПрепроцессораЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначеЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначе
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецЕсли Тогда
		ПосетитьИнструкциюПрепроцессора(Объявление);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявление Цикл
		Подписка.ПокинутьОбъявление(Объявление, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявление()

Процедура ПосетитьОбъявлениеСпискаПеременныхМодуля(ОбъявлениеСпискаПеременныхМодуля)
	Перем Подписка, ОбъявлениеПеременнойМодуля;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеСпискаПеременныхМодуля Цикл
		Подписка.ПосетитьОбъявлениеСпискаПеременныхМодуля(ОбъявлениеСпискаПеременныхМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОбъявлениеСпискаПеременныхМодуля);
	Для Каждого ОбъявлениеПеременнойМодуля Из ОбъявлениеСпискаПеременныхМодуля.ОбъявленияПеременных Цикл
		ПосетитьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля);
	КонецЦикла;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеСпискаПеременныхМодуля Цикл
		Подписка.ПокинутьОбъявлениеСпискаПеременныхМодуля(ОбъявлениеСпискаПеременныхМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеСпискаПеременныхМодуля()

Процедура ПосетитьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеПеременнойМодуля Цикл
		Подписка.ПосетитьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеПеременнойМодуля Цикл
		Подписка.ПокинутьОбъявлениеПеременнойМодуля(ОбъявлениеПеременнойМодуля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеПеременнойМодуля()

Процедура ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеЛокальнойПеременной Цикл
		Подписка.ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеЛокальнойПеременной Цикл
		Подписка.ПокинутьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеЛокальнойПеременной()

Процедура ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеПараметра Цикл
		Подписка.ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеПараметра Цикл
		Подписка.ПокинутьОбъявлениеПараметра(ОбъявлениеПараметра, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеПараметра()

Процедура ПосетитьОбъявлениеМетода(ОбъявлениеМетода)
	Перем Подписка, ОбъявлениеЛокальнойПеременной;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОбъявлениеМетода Цикл
		Подписка.ПосетитьОбъявлениеМетода(ОбъявлениеМетода, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОбъявлениеМетода);
	ПосетитьСигнатуру(ОбъявлениеМетода.Сигнатура);
	Для Каждого ОбъявлениеЛокальнойПеременной Из ОбъявлениеМетода.Переменные Цикл
		ПосетитьОбъявлениеЛокальнойПеременной(ОбъявлениеЛокальнойПеременной);
	КонецЦикла;
	ПосетитьОператоры(ОбъявлениеМетода.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОбъявлениеМетода Цикл
		Подписка.ПокинутьОбъявлениеМетода(ОбъявлениеМетода, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОбъявлениеМетода()

Процедура ПосетитьСигнатуру(Сигнатура)
	Перем Подписка, ОбъявлениеПараметра;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьСигнатуру Цикл
		Подписка.ПосетитьСигнатуру(Сигнатура, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(Сигнатура);
	Для Каждого ОбъявлениеПараметра Из Сигнатура.Параметры Цикл
		ПосетитьОбъявлениеПараметра(ОбъявлениеПараметра);
	КонецЦикла;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьСигнатуру Цикл
		Подписка.ПокинутьСигнатуру(Сигнатура, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьСигнатуру()

#КонецОбласти // ПосещениеОбъявлений

#Область ПосещениеВыражений

Процедура ПосетитьВыражение(Выражение)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражение Цикл
		Подписка.ПосетитьВыражение(Выражение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = Выражение.Тип;
	Если Тип = Узлы.ВыражениеЛитерал Тогда
		ПосетитьВыражениеЛитерал(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеИдентификатор Тогда
		ПосетитьВыражениеИдентификатор(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеУнарное Тогда
		ПосетитьВыражениеУнарное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеБинарное Тогда
		ПосетитьВыражениеБинарное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеНовый Тогда
		ПосетитьВыражениеНовый(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеТернарное Тогда
		ПосетитьВыражениеТернарное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеСкобочное Тогда
		ПосетитьВыражениеСкобочное(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеНе Тогда
		ПосетитьВыражениеНе(Выражение);
	ИначеЕсли Тип = Узлы.ВыражениеСтроковое Тогда
		ПосетитьВыражениеСтроковое(Выражение);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражение Цикл
		Подписка.ПокинутьВыражение(Выражение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражение()

Процедура ПосетитьВыражениеЛитерал(ВыражениеЛитерал)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеЛитерал Цикл
		Подписка.ПосетитьВыражениеЛитерал(ВыражениеЛитерал, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеЛитерал Цикл
		Подписка.ПокинутьВыражениеЛитерал(ВыражениеЛитерал, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеЛитерал()

Процедура ПосетитьВыражениеИдентификатор(ВыражениеИдентификатор)
	Перем Элемент, Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеИдентификатор Цикл
		Подписка.ПосетитьВыражениеИдентификатор(ВыражениеИдентификатор, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеИдентификатор);
	Если ВыражениеИдентификатор.Аргументы <> Неопределено Тогда
		Для Каждого Выражение Из ВыражениеИдентификатор.Аргументы Цикл
			Если Выражение <> Неопределено Тогда
				ПосетитьВыражение(Выражение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Для Каждого Элемент Из ВыражениеИдентификатор.Хвост Цикл
		Если Элемент.Тип = Узлы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражение(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Тип = Узлы.ВыражениеИндекс Тогда
			ПосетитьВыражение(Элемент.Выражение);
		Иначе
			ВызватьИсключение "нарушение протокола";
		КонецЕсли;
	КонецЦикла;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеИдентификатор Цикл
		Подписка.ПокинутьВыражениеИдентификатор(ВыражениеИдентификатор, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеИдентификатор()

Процедура ПосетитьВыражениеУнарное(ВыражениеУнарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеУнарное Цикл
		Подписка.ПосетитьВыражениеУнарное(ВыражениеУнарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеУнарное);
	ПосетитьВыражение(ВыражениеУнарное.Операнд);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеУнарное Цикл
		Подписка.ПокинутьВыражениеУнарное(ВыражениеУнарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеУнарное()

Процедура ПосетитьВыражениеБинарное(ВыражениеБинарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеБинарное Цикл
		Подписка.ПосетитьВыражениеБинарное(ВыражениеБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеБинарное);
	ПосетитьВыражение(ВыражениеБинарное.ЛевыйОперанд);
	ПосетитьВыражение(ВыражениеБинарное.ПравыйОперанд);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеБинарное Цикл
		Подписка.ПокинутьВыражениеБинарное(ВыражениеБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеБинарное()

Процедура ПосетитьВыражениеНовый(ВыражениеНовый)
	Перем Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеНовый Цикл
		Подписка.ПосетитьВыражениеНовый(ВыражениеНовый, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеНовый);
	Для Каждого Выражение Из ВыражениеНовый.Аргументы Цикл
		Если Выражение <> Неопределено Тогда
			ПосетитьВыражение(Выражение);
		КонецЕсли;
	КонецЦикла;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеНовый Цикл
		Подписка.ПокинутьВыражениеНовый(ВыражениеНовый, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеНовый()

Процедура ПосетитьВыражениеТернарное(ВыражениеТернарное)
	Перем Элемент, Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеТернарное Цикл
		Подписка.ПосетитьВыражениеТернарное(ВыражениеТернарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеТернарное);
	ПосетитьВыражение(ВыражениеТернарное.Выражение);
	ПосетитьВыражение(ВыражениеТернарное.Тогда);
	ПосетитьВыражение(ВыражениеТернарное.Иначе);
	Для Каждого Элемент Из ВыражениеТернарное.Хвост Цикл
		Если Элемент.Тип = Узлы.ВыражениеПоле Тогда
			Если Элемент.Аргументы <> Неопределено Тогда
				Для Каждого Выражение Из Элемент.Аргументы Цикл
					Если Выражение <> Неопределено Тогда
						ПосетитьВыражение(Выражение);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли Элемент.Тип = Узлы.ВыражениеИндекс Тогда
			ПосетитьВыражение(Элемент.Выражение);
		Иначе
			ВызватьИсключение "нарушение протокола";
		КонецЕсли;
	КонецЦикла;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеТернарное Цикл
		Подписка.ПокинутьВыражениеТернарное(ВыражениеТернарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеТернарное()

Процедура ПосетитьВыражениеСкобочное(ВыражениеСкобочное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеСкобочное Цикл
		Подписка.ПосетитьВыражениеСкобочное(ВыражениеСкобочное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеСкобочное);
	ПосетитьВыражение(ВыражениеСкобочное.Выражение);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеСкобочное Цикл
		Подписка.ПокинутьВыражениеСкобочное(ВыражениеСкобочное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеСкобочное()

Процедура ПосетитьВыражениеНе(ВыражениеНе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеНе Цикл
		Подписка.ПосетитьВыражениеНе(ВыражениеНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеНе);
	ПосетитьВыражение(ВыражениеНе.Выражение);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеНе Цикл
		Подписка.ПокинутьВыражениеНе(ВыражениеНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеНе()

Процедура ПосетитьВыражениеСтроковое(ВыражениеСтроковое)
	Перем Выражение, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеСтроковое Цикл
		Подписка.ПосетитьВыражениеСтроковое(ВыражениеСтроковое, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеСтроковое);
	Для Каждого Выражение Из ВыражениеСтроковое.Элементы Цикл
		ПосетитьВыражениеЛитерал(Выражение);
	КонецЦикла;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеСтроковое Цикл
		Подписка.ПокинутьВыражениеСтроковое(ВыражениеСтроковое, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеСтроковое()

#КонецОбласти // ПосещениеВыражений

#Область ПосещениеОператоров

Процедура ПосетитьОператор(Оператор)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператор Цикл
		Подписка.ПосетитьОператор(Оператор, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = Оператор.Тип;
	Если Тип = Узлы.ОператорПрисваивания Тогда
		ПосетитьОператорПрисваивания(Оператор);
	ИначеЕсли Тип = Узлы.ОператорВозврат Тогда
		ПосетитьОператорВозврат(Оператор);
	ИначеЕсли Тип = Узлы.ОператорПрервать Тогда
		ПосетитьОператорПрервать(Оператор);
	ИначеЕсли Тип = Узлы.ОператорПродолжить Тогда
		ПосетитьОператорПродолжить(Оператор);
	ИначеЕсли Тип = Узлы.ОператорВызватьИсключение Тогда
		ПосетитьОператорВызватьИсключение(Оператор);
	ИначеЕсли Тип = Узлы.ОператорВыполнить Тогда
		ПосетитьОператорВыполнить(Оператор);
	ИначеЕсли Тип = Узлы.ОператорВызоваПроцедуры Тогда
		ПосетитьОператорВызоваПроцедуры(Оператор);
	ИначеЕсли Тип = Узлы.ОператорЕсли Тогда
		ПосетитьОператорЕсли(Оператор);
	ИначеЕсли Тип = Узлы.ОператорПока Тогда
		ПосетитьОператорПока(Оператор);
	ИначеЕсли Тип = Узлы.ОператорДля Тогда
		ПосетитьОператорДля(Оператор);
	ИначеЕсли Тип = Узлы.ОператорДляКаждого Тогда
		ПосетитьОператорДляКаждого(Оператор);
	ИначеЕсли Тип = Узлы.ОператорПопытка Тогда
		ПосетитьОператорПопытка(Оператор);
	ИначеЕсли Тип = Узлы.ОператорПерейти Тогда
		ПосетитьОператорПерейти(Оператор);
	ИначеЕсли Тип = Узлы.ОператорМетка Тогда
		ПосетитьОператорМетка(Оператор);
	ИначеЕсли Тип = Узлы.ОператорДобавитьОбработчик Тогда
		ПосетитьОператорДобавитьОбработчик(Оператор);
	ИначеЕсли Тип = Узлы.ОператорУдалитьОбработчик Тогда
		ПосетитьОператорУдалитьОбработчик(Оператор);	
	ИначеЕсли Тип = Узлы.ИнструкцияПрепроцессораОбласть
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецОбласти
		Или Тип = Узлы.ИнструкцияПрепроцессораЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначеЕсли
		Или Тип = Узлы.ИнструкцияПрепроцессораИначе
		Или Тип = Узлы.ИнструкцияПрепроцессораКонецЕсли Тогда
		ПосетитьИнструкциюПрепроцессора(Оператор);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператор Цикл
		Подписка.ПокинутьОператор(Оператор, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператор()

Процедура ПосетитьОператорПрисваивания(ОператорПрисваивания)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПрисваивания Цикл
		Подписка.ПосетитьОператорПрисваивания(ОператорПрисваивания, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорПрисваивания);
	ПосетитьВыражениеИдентификатор(ОператорПрисваивания.ЛевыйОперанд);
	ПосетитьВыражение(ОператорПрисваивания.ПравыйОперанд);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПрисваивания Цикл
		Подписка.ПокинутьОператорПрисваивания(ОператорПрисваивания, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорПрисваивания()

Процедура ПосетитьОператорВозврат(ОператорВозврат)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВозврат Цикл
		Подписка.ПосетитьОператорВозврат(ОператорВозврат, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВозврат);
	Если ОператорВозврат.Выражение <> Неопределено Тогда
		ПосетитьВыражение(ОператорВозврат.Выражение);
	КонецЕсли;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВозврат Цикл
		Подписка.ПокинутьОператорВозврат(ОператорВозврат, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорВозврат()

Процедура ПосетитьОператорПрервать(ОператорПрервать)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПрервать Цикл
		Подписка.ПосетитьОператорПрервать(ОператорПрервать, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПрервать Цикл
		Подписка.ПокинутьОператорПрервать(ОператорПрервать, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорПрервать()

Процедура ПосетитьОператорПродолжить(ОператорПродолжить)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПродолжить Цикл
		Подписка.ПосетитьОператорПродолжить(ОператорПродолжить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПродолжить Цикл
		Подписка.ПокинутьОператорПродолжить(ОператорПродолжить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорПродолжить()

Процедура ПосетитьОператорВызватьИсключение(ОператорВызватьИсключение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВызватьИсключение Цикл
		Подписка.ПосетитьОператорВызватьИсключение(ОператорВызватьИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВызватьИсключение);
	Если ОператорВызватьИсключение.Выражение <> Неопределено Тогда
		ПосетитьВыражение(ОператорВызватьИсключение.Выражение);
	КонецЕсли;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВызватьИсключение Цикл
		Подписка.ПокинутьОператорВызватьИсключение(ОператорВызватьИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорВызватьИсключение()

Процедура ПосетитьОператорВыполнить(ОператорВыполнить)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВыполнить Цикл
		Подписка.ПосетитьОператорВыполнить(ОператорВыполнить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВыполнить);
	ПосетитьВыражение(ОператорВыполнить.Выражение);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВыполнить Цикл
		Подписка.ПокинутьОператорВыполнить(ОператорВыполнить, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорВыполнить()

Процедура ПосетитьОператорВызоваПроцедуры(ОператорВызоваПроцедуры)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорВызоваПроцедуры Цикл
		Подписка.ПосетитьОператорВызоваПроцедуры(ОператорВызоваПроцедуры, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорВызоваПроцедуры);
	ПосетитьВыражениеИдентификатор(ОператорВызоваПроцедуры.Идентификатор);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорВызоваПроцедуры Цикл
		Подписка.ПокинутьОператорВызоваПроцедуры(ОператорВызоваПроцедуры, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорВызоваПроцедуры()

Процедура ПосетитьОператорЕсли(ОператорЕсли)
	Перем ОператорИначеЕсли, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорЕсли Цикл
		Подписка.ПосетитьОператорЕсли(ОператорЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорЕсли);
	ПосетитьВыражение(ОператорЕсли.Выражение);
	ПосетитьОператоры(ОператорЕсли.Тогда);
	Если ОператорЕсли.ИначеЕсли <> Неопределено Тогда
		Для Каждого ОператорИначеЕсли Из ОператорЕсли.ИначеЕсли Цикл
			ПосетитьОператорИначеЕсли(ОператорИначеЕсли);
		КонецЦикла;
	КонецЕсли;
	Если ОператорЕсли.Иначе <> Неопределено Тогда
		ПосетитьОператорИначе(ОператорЕсли.Иначе);
	КонецЕсли;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорЕсли Цикл
		Подписка.ПокинутьОператорЕсли(ОператорЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорЕсли()

Процедура ПосетитьОператорИначеЕсли(ОператорИначеЕсли)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорИначеЕсли Цикл
		Подписка.ПосетитьОператорИначеЕсли(ОператорИначеЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорИначеЕсли);
	ПосетитьВыражение(ОператорИначеЕсли.Выражение);
	ПосетитьОператоры(ОператорИначеЕсли.Тогда);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорИначеЕсли Цикл
		Подписка.ПокинутьОператорИначеЕсли(ОператорИначеЕсли, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорИначеЕсли()

Процедура ПосетитьОператорИначе(ОператорИначе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорИначе Цикл
		Подписка.ПосетитьОператорИначе(ОператорИначе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорИначе);
	ПосетитьОператоры(ОператорИначе.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорИначе Цикл
		Подписка.ПокинутьОператорИначе(ОператорИначе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорИначе()

Процедура ПосетитьОператорПока(ОператорПока)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПока Цикл
		Подписка.ПосетитьОператорПока(ОператорПока, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорПока);
	ПосетитьВыражение(ОператорПока.Выражение);
	ПосетитьОператоры(ОператорПока.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПока Цикл
		Подписка.ПокинутьОператорПока(ОператорПока, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорПока()

Процедура ПосетитьОператорДля(ОператорДля)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорДля Цикл
		Подписка.ПосетитьОператорДля(ОператорДля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорДля);
	ПосетитьВыражениеИдентификатор(ОператорДля.Идентификатор);
	ПосетитьВыражение(ОператорДля.Начало);
	ПосетитьВыражение(ОператорДля.Конец);
	ПосетитьОператоры(ОператорДля.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорДля Цикл
		Подписка.ПокинутьОператорДля(ОператорДля, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорДля()

Процедура ПосетитьОператорДляКаждого(ОператорДляКаждого)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорДляКаждого Цикл
		Подписка.ПосетитьОператорДляКаждого(ОператорДляКаждого, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорДляКаждого);
	ПосетитьВыражениеИдентификатор(ОператорДляКаждого.Идентификатор);
	ПосетитьВыражение(ОператорДляКаждого.Коллекция);
	ПосетитьОператоры(ОператорДляКаждого.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорДляКаждого Цикл
		Подписка.ПокинутьОператорДляКаждого(ОператорДляКаждого, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорДляКаждого()

Процедура ПосетитьОператорПопытка(ОператорПопытка)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПопытка Цикл
		Подписка.ПосетитьОператорПопытка(ОператорПопытка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорПопытка);
	ПосетитьОператоры(ОператорПопытка.Попытка);
	ПосетитьОператорИсключение(ОператорПопытка.Исключение);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПопытка Цикл
		Подписка.ПокинутьОператорПопытка(ОператорПопытка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорПопытка()

Процедура ПосетитьОператорИсключение(ОператорИсключение)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорИсключение Цикл
		Подписка.ПосетитьОператорИсключение(ОператорИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорИсключение);
	ПосетитьОператоры(ОператорИсключение.Операторы);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорИсключение Цикл
		Подписка.ПокинутьОператорИсключение(ОператорИсключение, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорИсключение()

Процедура ПосетитьОператорПерейти(ОператорПерейти)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорПерейти Цикл
		Подписка.ПосетитьОператорПерейти(ОператорПерейти, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорПерейти Цикл
		Подписка.ПокинутьОператорПерейти(ОператорПерейти, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорПерейти()

Процедура ПосетитьОператорМетка(ОператорМетка)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорМетка Цикл
		Подписка.ПосетитьОператорМетка(ОператорМетка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорМетка Цикл
		Подписка.ПокинутьОператорМетка(ОператорМетка, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорМетка()

Процедура ПосетитьОператорДобавитьОбработчик(ОператорДобавитьОбработчик)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорДобавитьОбработчик Цикл
		Подписка.ПосетитьОператорДобавитьОбработчик(ОператорДобавитьОбработчик, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорДобавитьОбработчик);
	ПосетитьВыражениеИдентификатор(ОператорДобавитьОбработчик.Событие);
	ПосетитьВыражениеИдентификатор(ОператорДобавитьОбработчик.ОбработчикСобытия);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорДобавитьОбработчик Цикл
		Подписка.ПокинутьОператорДобавитьОбработчик(ОператорДобавитьОбработчик, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорДобавитьОбработчик()

Процедура ПосетитьОператорУдалитьОбработчик(ОператорУдалитьОбработчик)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьОператорУдалитьОбработчик Цикл
		Подписка.ПосетитьОператорУдалитьОбработчик(ОператорУдалитьОбработчик, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ОператорУдалитьОбработчик);
	ПосетитьВыражениеИдентификатор(ОператорУдалитьОбработчик.Событие);
	ПосетитьВыражениеИдентификатор(ОператорУдалитьОбработчик.ОбработчикСобытия);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьОператорУдалитьОбработчик Цикл
		Подписка.ПокинутьОператорУдалитьОбработчик(ОператорУдалитьОбработчик, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьОператорУдалитьОбработчик()

#КонецОбласти // ПосещениеОператоров

#Область ПосещениеВыраженийПрепроцессора

Процедура ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессора)
	Перем Тип, Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессора Цикл
		Подписка.ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Тип = ВыражениеПрепроцессора.Тип;
	Если Тип = Узлы.ВыражениеПрепроцессораСимвол Тогда
		ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессора);
	ИначеЕсли Тип = Узлы.ВыражениеПрепроцессораБинарное Тогда
		ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессора);
	ИначеЕсли Тип = Узлы.ВыражениеПрепроцессораНе Тогда
		ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессора);
	ИначеЕсли Тип = Узлы.ВыражениеПрепроцессораСкобочное Тогда
		ПосетитьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессора);
	КонецЕсли;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессора Цикл
		Подписка.ПокинутьВыражениеПрепроцессора(ВыражениеПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессора()

Процедура ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораСимвол Цикл
		Подписка.ПосетитьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораСимвол Цикл
		Подписка.ПокинутьВыражениеПрепроцессораСимвол(ВыражениеПрепроцессораСимвол, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораСимвол()

Процедура ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораБинарное Цикл
		Подписка.ПосетитьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеПрепроцессораБинарное);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораБинарное.ЛевыйОперанд);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораБинарное.ПравыйОперанд);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораБинарное Цикл
		Подписка.ПокинутьВыражениеПрепроцессораБинарное(ВыражениеПрепроцессораБинарное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораБинарное()

Процедура ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораНе Цикл
		Подписка.ПосетитьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеПрепроцессораНе);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораНе.Выражение);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораНе Цикл
		Подписка.ПокинутьВыражениеПрепроцессораНе(ВыражениеПрепроцессораНе, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораНе()

Процедура ПосетитьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессораСкобочное)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьВыражениеПрепроцессораСкобочное Цикл
		Подписка.ПосетитьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессораСкобочное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ВыражениеПрепроцессораСкобочное);
	ПосетитьВыражениеПрепроцессора(ВыражениеПрепроцессораСкобочное.Выражение);
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьВыражениеПрепроцессораСкобочное Цикл
		Подписка.ПокинутьВыражениеПрепроцессораСкобочное(ВыражениеПрепроцессораСкобочное, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьВыражениеПрепроцессораСкобочное()

Процедура ПосетитьИнструкциюПрепроцессора(ИнструкцияПрепроцессора)
	Перем Подписка;
	Для Каждого Подписка Из Посетитель_Подписки.ПосетитьИнструкциюПрепроцессора Цикл
		Подписка.ПосетитьИнструкциюПрепроцессора(ИнструкцияПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
	ДобавитьНаСтек(ИнструкцияПрепроцессора);
	Если ИнструкцияПрепроцессора.Свойство("Выражение") Тогда
		ПосетитьВыражениеПрепроцессора(ИнструкцияПрепроцессора.Выражение);
	КонецЕсли;
	СнятьСоСтека();
	Для Каждого Подписка Из Посетитель_Подписки.ПокинутьИнструкциюПрепроцессора Цикл
		Подписка.ПокинутьИнструкциюПрепроцессора(ИнструкцияПрепроцессора, Посетитель_Стек, Посетитель_Счетчики);
	КонецЦикла;
КонецПроцедуры // ПосетитьИнструкциюПрепроцессора()

#КонецОбласти // ПосещениеВыраженийПрепроцессора

#КонецОбласти // Посетитель

Процедура Пуск(Исходник, Знач Плагины, Контекст = Неопределено) Экспорт

	Подключить(Плагины);
	Посетить(Разобрать(Исходник, Контекст));

КонецПроцедуры // Пуск()

Инициализировать();